/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
const code = require('vscode');
const types = require('vscode-languageserver-types');
const is = require('./utils/is');
const protocolCompletionItem_1 = require('./protocolCompletionItem');
const protocolCodeLens_1 = require('./protocolCodeLens');
function createConverter(uriConverter) {
    const nullConverter = (value) => value.toString();
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri)
        };
    }
    function asVersionedTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri),
            version: textDocument.version
        };
    }
    function asOpenTextDocumentParams(textDocument) {
        return {
            textDocument: {
                uri: _uriConverter(textDocument.uri),
                languageId: textDocument.languageId,
                version: textDocument.version,
                text: textDocument.getText()
            }
        };
    }
    function isTextDocumentChangeEvent(value) {
        let candidate = value;
        return is.defined(candidate.document) && is.defined(candidate.contentChanges);
    }
    function isTextDocument(value) {
        let candidate = value;
        return is.defined(candidate.uri) && is.defined(candidate.version);
    }
    function asChangeTextDocumentParams(arg) {
        if (isTextDocument(arg)) {
            let result = {
                textDocument: {
                    uri: _uriConverter(arg.uri),
                    version: arg.version
                },
                contentChanges: [{ text: arg.getText() }]
            };
            return result;
        }
        else if (isTextDocumentChangeEvent(arg)) {
            let document = arg.document;
            let result = {
                textDocument: {
                    uri: _uriConverter(document.uri),
                    version: document.version
                },
                contentChanges: arg.contentChanges.map((change) => {
                    let range = change.range;
                    return {
                        range: {
                            start: { line: range.start.line, character: range.start.character },
                            end: { line: range.end.line, character: range.end.character }
                        },
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                })
            };
            return result;
        }
        else {
            throw Error('Unsupported text document change parameter');
        }
    }
    function asCloseTextDocumentParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
            textDocument: asVersionedTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
            result.content = textDocument.getText();
        }
        return result;
    }
    function asWillSaveTextDocumentParams(event) {
        return {
            textDocument: asTextDocumentIdentifier(event.document),
            reason: event.reason
        };
    }
    function asTextDocumentPositionParams(textDocument, position) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position)
        };
    }
    function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
    }
    function asRange(value) {
        if (is.undefined(value)) {
            return undefined;
        }
        else if (is.nil(value)) {
            return null;
        }
        return { start: asPosition(value.start), end: asPosition(value.end) };
    }
    function asPosition(value) {
        if (is.undefined(value)) {
            return undefined;
        }
        else if (is.nil(value)) {
            return null;
        }
        return { line: value.line, character: value.character };
    }
    function set(value, func) {
        if (is.defined(value)) {
            func();
        }
    }
    function asDiagnosticSeverity(value) {
        switch (value) {
            case code.DiagnosticSeverity.Error:
                return 1 /* Error */;
            case code.DiagnosticSeverity.Warning:
                return 2 /* Warning */;
            case code.DiagnosticSeverity.Information:
                return 3 /* Information */;
            case code.DiagnosticSeverity.Hint:
                return 4 /* Hint */;
        }
    }
    function asDiagnostic(item) {
        let result = types.Diagnostic.create(asRange(item.range), item.message);
        set(item.severity, () => result.severity = asDiagnosticSeverity(item.severity));
        set(item.code, () => result.code = item.code);
        set(item.source, () => result.source = item.source);
        return result;
    }
    function asDiagnostics(items) {
        if (is.undefined(items) || is.nil(items)) {
            return items;
        }
        return items.map(asDiagnostic);
    }
    function asCompletionItem(item) {
        let result = { label: item.label };
        set(item.detail, () => result.detail = item.detail);
        set(item.documentation, () => result.documentation = item.documentation);
        set(item.filterText, () => result.filterText = item.filterText);
        set(item.insertText, () => result.insertText = asCompletionInsertText(item.insertText));
        set(item.range, () => result.range = asRange(item.range));
        // Protocol item kind is 1 based, codes item kind is zero based.
        set(item.kind, () => result.kind = item.kind + 1);
        set(item.sortText, () => result.sortText = item.sortText);
        set(item.textEdit, () => result.textEdit = asTextEdit(item.textEdit));
        set(item.additionalTextEdits, () => result.additionalTextEdits = asTextEdits(item.additionalTextEdits));
        set(item.command, () => result.command = asCommand(item.command));
        if (item instanceof protocolCompletionItem_1.default) {
            set(item.data, () => result.data = item.data);
        }
        return result;
    }
    function asCompletionInsertText(text) {
        if (is.string(text)) {
            return text;
        }
        else if (is.defined(text.value)) {
            return types.SnippetString.create(text.value);
        }
        return undefined;
    }
    function asTextEdit(edit) {
        return { range: asRange(edit.range), newText: edit.newText };
    }
    function asTextEdits(edits) {
        if (is.undefined(edits) || is.nil(edits)) {
            return edits;
        }
        return edits.map(asTextEdit);
    }
    function asReferenceParams(textDocument, position, options) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: { includeDeclaration: options.includeDeclaration }
        };
    }
    function asCodeActionContext(context) {
        if (is.undefined(context) || is.nil(context)) {
            return context;
        }
        return types.CodeActionContext.create(asDiagnostics(context.diagnostics));
    }
    function asCommand(item) {
        let result = types.Command.create(item.title, item.command);
        if (is.defined(item.arguments))
            result.arguments = item.arguments;
        return result;
    }
    function asCodeLens(item) {
        let result = types.CodeLens.create(asRange(item.range));
        if (is.defined(item.command))
            result.command = asCommand(item.command);
        if (item instanceof protocolCodeLens_1.default) {
            if (is.defined(item.data))
                result.data = item.data;
        }
        return result;
    }
    function asFormattingOptions(item) {
        return { tabSize: item.tabSize, insertSpaces: item.insertSpaces };
    }
    function asDocumentSymbolParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCodeLensParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asDocumentLink(item) {
        let result = types.DocumentLink.create(asRange(item.range));
        if (is.defined(item.target))
            result.target = asUri(item.target);
        return result;
    }
    function asDocumentLinkParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    return {
        asUri,
        asTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asTextDocumentPositionParams,
        asWorkerPosition,
        asRange,
        asPosition,
        asDiagnosticSeverity,
        asDiagnostic,
        asDiagnostics,
        asCompletionItem,
        asTextEdit,
        asReferenceParams,
        asCodeActionContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams
    };
}
exports.createConverter = createConverter;
