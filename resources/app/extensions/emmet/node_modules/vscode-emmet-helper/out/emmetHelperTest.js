"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const emmetHelper_1 = require("./emmetHelper");
const mocha_1 = require("mocha");
const assert = require("assert");
const path = require("path");
const extensionsPath = path.join(path.normalize(path.join(__dirname, '..')), 'testData');
mocha_1.describe('Validate Abbreviations', () => {
    mocha_1.it('should return true for valid abbreivations', () => {
        const htmlAbbreviations = ['ul>li', 'ul', 'h1', 'ul>li*3', '(ul>li)+div', '.hello', '!', '#hello', '.item[id=ok]'];
        htmlAbbreviations.forEach(abbr => {
            assert(emmetHelper_1.isAbbreviationValid('html', abbr));
        });
        htmlAbbreviations.forEach(abbr => {
            assert(emmetHelper_1.isAbbreviationValid('haml', abbr));
        });
    });
    mocha_1.it('should return false for invalid abbreivations', () => {
        const htmlAbbreviations = ['!ul!', '(hello)'];
        const cssAbbreviations = ['123'];
        htmlAbbreviations.forEach(abbr => {
            assert(!emmetHelper_1.isAbbreviationValid('html', abbr));
        });
        htmlAbbreviations.forEach(abbr => {
            assert(!emmetHelper_1.isAbbreviationValid('haml', abbr));
        });
        cssAbbreviations.forEach(abbr => {
            assert(!emmetHelper_1.isAbbreviationValid('css', abbr));
        });
        cssAbbreviations.forEach(abbr => {
            assert(!emmetHelper_1.isAbbreviationValid('scss', abbr));
        });
    });
});
mocha_1.describe('Extract Abbreviations', () => {
    mocha_1.it('should extract abbreviations from document', () => {
        const testCases = [
            ['<div>ul>li*3</div>', 0, 7, 'ul', 0, 5, 0, 7, []],
            ['<div>ul>li*3</div>', 0, 10, 'ul>li', 0, 5, 0, 10, []],
            ['<div>ul>li*3</div>', 0, 12, 'ul>li*3', 0, 5, 0, 12, []],
            ['ul>li', 0, 5, 'ul>li', 0, 0, 0, 5, []],
            ['ul>li|bem', 0, 9, 'ul>li', 0, 0, 0, 9, ['bem']]
        ];
        testCases.forEach(([content, positionLine, positionChar, expectedAbbr, expectedRangeStartLine, expectedRangeStartChar, expectedRangeEndLine, expectedRangeEndChar, expectedFilters]) => {
            const document = vscode_languageserver_types_1.TextDocument.create('test://test/test.html', 'html', 0, content);
            const position = vscode_languageserver_types_1.Position.create(positionLine, positionChar);
            const { abbreviationRange, abbreviation, filters } = emmetHelper_1.extractAbbreviation(document, position);
            assert.equal(expectedAbbr, abbreviation);
            assert.equal(expectedRangeStartLine, abbreviationRange.start.line);
            assert.equal(expectedRangeStartChar, abbreviationRange.start.character);
            assert.equal(expectedRangeEndLine, abbreviationRange.end.line);
            assert.equal(expectedRangeEndChar, abbreviationRange.end.character);
            assert.equal(filters.length, expectedFilters.length);
            for (let i = 0; i < filters.length; i++) {
                assert.equal(filters[i], expectedFilters[i]);
            }
        });
    });
    mocha_1.it('should extract abbreviations from text', () => {
        const testCases = [
            ['ul', 'ul', []],
            ['ul>li', 'ul>li', []],
            ['ul>li*3', 'ul>li*3', []],
            ['ul>li|bem', 'ul>li', ['bem']],
            ['ul>li|t', 'ul>li', ['t']]
        ];
        testCases.forEach(([content, expectedAbbr, expectedFilters]) => {
            const { abbreviation, filters } = emmetHelper_1.extractAbbreviationFromText(content);
            assert.equal(expectedAbbr, abbreviation);
            assert.equal(filters.length, expectedFilters.length);
            for (let i = 0; i < filters.length; i++) {
                assert.equal(filters[i], expectedFilters[i]);
            }
        });
    });
});
mocha_1.describe('Test Basic Expand Options', () => {
    mocha_1.it('should check for basic expand options', () => {
        const textToReplace = 'textToReplace';
        const syntax = 'anythingreally';
        let expandOptions = emmetHelper_1.getExpandOptions(syntax);
        assert.equal(expandOptions.field, emmetHelper_1.emmetSnippetField);
        assert.equal(expandOptions.syntax, syntax);
    });
});
mocha_1.describe('Test output profile settings', () => {
    mocha_1.it('should convert output profile from old format to new', () => {
        const profile = {
            tag_case: 'lower',
            attr_case: 'lower',
            attr_quotes: 'single',
            tag_nl: true,
            inline_break: 2,
            self_closing_tag: 'xhtml'
        };
        const expandOptions = emmetHelper_1.getExpandOptions('html', { html: profile });
        assert.equal(profile['tag_case'], expandOptions.profile['tagCase']);
        assert.equal(profile['attr_case'], expandOptions.profile['attributeCase']);
        assert.equal(profile['attr_quotes'], expandOptions.profile['attributeQuotes']);
        assert.equal(profile['tag_nl'], expandOptions.profile['format']);
        assert.equal(profile['inline_break'], expandOptions.profile['inlineBreak']);
        assert.equal(profile['self_closing_tag'], expandOptions.profile['selfClosingStyle']);
    });
    mocha_1.it('should convert self_closing_style', () => {
        const testCases = [true, false, 'xhtml'];
        const expectedValue = ['xml', 'html', 'xhtml'];
        for (let i = 0; i < testCases.length; i++) {
            const expandOptions = emmetHelper_1.getExpandOptions('html', { html: { self_closing_tag: testCases[i] } });
            assert.equal(expandOptions.profile['selfClosingStyle'], expectedValue[i]);
        }
    });
    mocha_1.it('should convert tag_nl', () => {
        const testCases = [true, false, 'decide'];
        const expectedValue = [true, false, true];
        for (let i = 0; i < testCases.length; i++) {
            const expandOptions = emmetHelper_1.getExpandOptions('html', { html: { tag_nl: testCases[i] } });
            assert.equal(expandOptions.profile['format'], expectedValue[i]);
        }
    });
    mocha_1.it('shoud use output profile in new format as is', () => {
        const profile = {
            tagCase: 'lower',
            attributeCase: 'lower',
            attributeQuotes: 'single',
            format: true,
            inlineBreak: 2,
            selfClosingStyle: 'xhtml'
        };
        const expandOptions = emmetHelper_1.getExpandOptions('html', { html: profile });
        Object.keys(profile).forEach(key => {
            assert.equal(expandOptions.profile[key], profile[key]);
        });
    });
    mocha_1.it('should use profile from settings that overrides the ones from extensionsPath', () => {
        return emmetHelper_1.updateExtensionsPath(extensionsPath).then(() => {
            const profile = {
                tag_case: 'lower',
                attr_case: 'lower',
                attr_quotes: 'single',
                tag_nl: true,
                inline_break: 2,
                self_closing_tag: 'xhtml'
            };
            const expandOptions = emmetHelper_1.getExpandOptions('html', { html: profile });
            assert.equal(expandOptions.profile['tagCase'], 'lower');
            assert.equal(profile['tag_case'], 'lower');
            return Promise.resolve();
        });
    });
});
mocha_1.describe('Test variables settings', () => {
    mocha_1.it('should take in variables as is', () => {
        const variables = {
            lang: 'de',
            charset: 'UTF-8'
        };
        const expandOptions = emmetHelper_1.getExpandOptions('html', {}, variables);
        Object.keys(variables).forEach(key => {
            assert.equal(expandOptions.variables[key], variables[key]);
        });
    });
    mocha_1.it('should use variables from extensionsPath', () => {
        emmetHelper_1.updateExtensionsPath(extensionsPath).then(() => {
            const variables = {
                lang: 'en',
                charset: 'UTF-8'
            };
            const expandOptions = emmetHelper_1.getExpandOptions('html', {}, variables);
            assert.equal(expandOptions.variables['lang'], 'fr');
            assert.equal(variables['lang'], 'en');
        });
    });
});
mocha_1.describe('Test custom snippets', () => {
    mocha_1.it('should use custom snippets from extensionsPath', () => {
        const customSnippetKey = 'ch';
        return emmetHelper_1.updateExtensionsPath(null).then(() => {
            const expandOptionsWithoutCustomSnippets = emmetHelper_1.getExpandOptions('css');
            assert(!expandOptionsWithoutCustomSnippets.snippets);
            // Use custom snippets from extensionsPath
            return emmetHelper_1.updateExtensionsPath(extensionsPath).then(() => {
                let foundCustomSnippet = false;
                let foundCustomSnippetInInhertitedSyntax = false;
                const expandOptionsWithCustomSnippets = emmetHelper_1.getExpandOptions('css');
                const expandOptionsWithCustomSnippetsInhertedSytnax = emmetHelper_1.getExpandOptions('scss');
                expandOptionsWithCustomSnippets.snippets.all({ type: 'string' }).forEach(snippet => {
                    if (snippet.key === customSnippetKey) {
                        foundCustomSnippet = true;
                    }
                });
                expandOptionsWithCustomSnippetsInhertedSytnax.snippets.all({ type: 'string' }).forEach(snippet => {
                    if (snippet.key === customSnippetKey) {
                        foundCustomSnippetInInhertitedSyntax = true;
                    }
                });
                assert.equal(foundCustomSnippet, true);
                assert.equal(foundCustomSnippetInInhertitedSyntax, true);
                return Promise.resolve();
            });
        });
    });
});
mocha_1.describe('Test completions', () => {
    mocha_1.it('should provide completions', () => {
        return emmetHelper_1.updateExtensionsPath(null).then(() => {
            const testCases = [
                ['<div>ul>li*3</div>', 0, 7, 'ul', '<ul>|</ul>'],
                ['<div>ul>li*3</div>', 0, 10, 'ul>li', '<ul>\n\t<li>|</li>\n</ul>'],
                ['<div>(ul>li)*3</div>', 0, 14, '(ul>li)*3', '<ul>\n\t<li>|</li>\n</ul>\n<ul>\n\t<li>|</li>\n</ul>\n<ul>\n\t<li>|</li>\n</ul>']
            ];
            testCases.forEach(([content, positionLine, positionChar, expectedAbbr, expectedExpansion]) => {
                const document = vscode_languageserver_types_1.TextDocument.create('test://test/test.html', 'html', 0, content);
                const position = vscode_languageserver_types_1.Position.create(positionLine, positionChar);
                const completionList = emmetHelper_1.doComplete(document, position, 'html', {
                    useNewEmmet: true,
                    showExpandedAbbreviation: 'always',
                    showAbbreviationSuggestions: false,
                    syntaxProfiles: {},
                    variables: {}
                });
                assert.equal(completionList.items[0].label, expectedAbbr);
                assert.equal(completionList.items[0].documentation, expectedExpansion);
            });
            return Promise.resolve();
        });
    });
    mocha_1.it('should provide completions using custom snippets', () => {
        return emmetHelper_1.updateExtensionsPath(extensionsPath).then(() => {
            const testCases = [
                ['<div>hey</div>', 0, 8, 'hey', '<ul>\n\t<li><span class="hello">|</span></li>\n\t<li><span class="hello">|</span></li>\n</ul>']
            ];
            testCases.forEach(([content, positionLine, positionChar, expectedAbbr, expectedExpansion]) => {
                const document = vscode_languageserver_types_1.TextDocument.create('test://test/test.html', 'html', 0, content);
                const position = vscode_languageserver_types_1.Position.create(positionLine, positionChar);
                const completionList = emmetHelper_1.doComplete(document, position, 'html', {
                    useNewEmmet: true,
                    showExpandedAbbreviation: 'always',
                    showAbbreviationSuggestions: false,
                    syntaxProfiles: {
                        'html': {
                            'tag_case': 'lower'
                        }
                    },
                    variables: {}
                });
                assert.equal(completionList.items[0].label, expectedAbbr);
                assert.equal(completionList.items[0].documentation, expectedExpansion);
            });
            return Promise.resolve();
        });
    });
    mocha_1.it('should not provide completions', () => {
        return emmetHelper_1.updateExtensionsPath(null).then(() => {
            const testCases = [
                ['<div>abc</div>', 0, 8],
                ['<div>abc12</div>', 0, 10],
                ['<div>abc.</div>', 0, 9],
                ['<div>(div)</div>', 0, 10]
            ];
            testCases.forEach(([content, positionLine, positionChar]) => {
                const document = vscode_languageserver_types_1.TextDocument.create('test://test/test.html', 'html', 0, content);
                const position = vscode_languageserver_types_1.Position.create(positionLine, positionChar);
                const completionList = emmetHelper_1.doComplete(document, position, 'html', {
                    useNewEmmet: true,
                    showExpandedAbbreviation: 'always',
                    showAbbreviationSuggestions: false,
                    syntaxProfiles: {},
                    variables: {}
                });
                assert.equal(completionList.items.length, 0);
            });
            return Promise.resolve();
        });
    });
    mocha_1.it('should provide completions for lorem', () => {
        return emmetHelper_1.updateExtensionsPath(null).then(() => {
            const document = vscode_languageserver_types_1.TextDocument.create('test://test/test.html', 'html', 0, 'lorem10.item');
            const position = vscode_languageserver_types_1.Position.create(0, 12);
            const completionList = emmetHelper_1.doComplete(document, position, 'html', {
                useNewEmmet: true,
                showExpandedAbbreviation: 'always',
                showAbbreviationSuggestions: false,
                syntaxProfiles: {},
                variables: {}
            });
            const expandedText = completionList.items[0].documentation;
            let matches = expandedText.match(/<div class="item">(.*)<\/div>/);
            assert.equal(completionList.items[0].label, 'lorem10.item');
            assert.equal(matches != null, true);
            assert.equal(matches[1].split(' ').length, 10);
            assert.equal(matches[1].startsWith('Lorem'), true);
            return Promise.resolve();
        });
    });
});
