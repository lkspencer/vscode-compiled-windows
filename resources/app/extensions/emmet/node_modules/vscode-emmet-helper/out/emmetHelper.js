"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const vscode = require("vscode");
const expand_abbreviation_1 = require("@emmetio/expand-abbreviation");
const extract = require("@emmetio/extract-abbreviation");
const path = require("path");
const fs = require("fs");
const snippetKeyCache = new Map();
const htmlAbbreviationStartRegex = /^[a-z,A-Z,!,(,[,#,\.]/;
const htmlAbbreviationEndRegex = /[a-z,A-Z,!,),\],#,\.,},\d,*,$]$/;
const cssAbbreviationRegex = /^[a-z,A-Z,!,@,#]/;
const emmetModes = ['html', 'pug', 'slim', 'haml', 'xml', 'xsl', 'jsx', 'css', 'scss', 'sass', 'less', 'stylus'];
class EmmetCompletionItemProvider {
    constructor(syntax) {
        if (syntax) {
            this._syntax = syntax;
        }
    }
    provideCompletionItems(document, position, token) {
        let emmetConfig = vscode.workspace.getConfiguration('emmet');
        if (!emmetConfig['useNewEmmet']
            || emmetConfig['showExpandedAbbreviation'] === false
            || emmetConfig['showExpandedAbbreviation'] === 'never'
            || emmetModes.indexOf(this._syntax) === -1) {
            return Promise.resolve(null);
        }
        let expandedAbbr;
        let [abbreviationRange, abbreviation] = extractAbbreviation(document, position);
        if (isAbbreviationValid(this._syntax, abbreviation)) {
            let expandedText;
            try {
                expandedText = expand_abbreviation_1.expand(abbreviation, getExpandOptions(this._syntax));
            }
            catch (e) {
            }
            if (expandedText) {
                expandedAbbr = new vscode.CompletionItem(abbreviation);
                expandedAbbr.insertText = new vscode.SnippetString(expandedText);
                expandedAbbr.documentation = this.removeTabStops(expandedText);
                expandedAbbr.range = abbreviationRange;
                expandedAbbr.detail = 'Emmet Abbreviation';
                if (isStyleSheet(this._syntax)) {
                    // Temporary fix for https://github.com/Microsoft/vscode/issues/28933
                    expandedAbbr.filterText = abbreviation;
                    expandedAbbr.sortText = expandedAbbr.documentation;
                    expandedAbbr.label = expandedAbbr.documentation;
                    return Promise.resolve(new vscode.CompletionList([expandedAbbr], true));
                }
            }
        }
        let completionItems = expandedAbbr ? [expandedAbbr] : [];
        if (!isStyleSheet(this._syntax)) {
            if (expandedAbbr) {
                // Workaround for the main expanded abbr not appearing before the snippet suggestions
                expandedAbbr.sortText = '0' + expandedAbbr.label;
            }
            let currentWord = this.getCurrentWord(document, position);
            let abbreviationSuggestions = this.getAbbreviationSuggestions(this._syntax, currentWord, abbreviation, abbreviationRange);
            completionItems = completionItems.concat(abbreviationSuggestions);
        }
        return Promise.resolve(new vscode.CompletionList(completionItems, true));
    }
    getAbbreviationSuggestions(syntax, prefix, abbreviation, abbreviationRange) {
        if (!vscode.workspace.getConfiguration('emmet')['showAbbreviationSuggestions'] || !prefix || !abbreviation) {
            return [];
        }
        if (!snippetKeyCache.has(syntax)) {
            let registry = expand_abbreviation_1.createSnippetsRegistry(syntax);
            let snippetKeys = registry.all({ type: 'string' }).map(snippet => {
                return snippet.key;
            });
            snippetKeyCache.set(syntax, snippetKeys);
        }
        let snippetKeys = snippetKeyCache.get(syntax);
        let snippetCompletions = [];
        snippetKeys.forEach(snippetKey => {
            if (!snippetKey.startsWith(prefix) || snippetKey === prefix) {
                return;
            }
            let currentAbbr = abbreviation + snippetKey.substr(prefix.length);
            let expandedAbbr;
            try {
                expandedAbbr = expand_abbreviation_1.expand(currentAbbr, getExpandOptions(syntax));
            }
            catch (e) {
            }
            let item = new vscode.CompletionItem(snippetKey);
            item.documentation = this.removeTabStops(expandedAbbr);
            item.detail = 'Emmet Abbreviation';
            item.insertText = new vscode.SnippetString(expandedAbbr);
            item.range = abbreviationRange;
            // Workaround for snippet suggestions items getting filtered out as the complete abbr does not start with snippetKey 
            item.filterText = abbreviation;
            // Workaround for the main expanded abbr not appearing before the snippet suggestions
            item.sortText = '9' + abbreviation;
            snippetCompletions.push(item);
        });
        return snippetCompletions;
    }
    getCurrentWord(document, position) {
        let currentLine = document.lineAt(position.line).text;
        let matches = currentLine.match(/[\w,:]*$/);
        if (matches) {
            return matches[0];
        }
    }
    removeTabStops(expandedWord) {
        return expandedWord.replace(/\$\{\d+\}/g, '').replace(/\$\{\d+:([^\}]+)\}/g, '$1');
    }
}
exports.EmmetCompletionItemProvider = EmmetCompletionItemProvider;
let variablesFromFile = {};
let profilesFromFile = {};
let emmetExtensionsPath = '';
const field = (index, placeholder) => `\${${index}${placeholder ? ':' + placeholder : ''}}`;
function isStyleSheet(syntax) {
    let stylesheetSyntaxes = ['css', 'scss', 'sass', 'less', 'stylus'];
    return (stylesheetSyntaxes.indexOf(syntax) > -1);
}
exports.isStyleSheet = isStyleSheet;
/**
 * Extracts abbreviation from the given position in the given document
 */
function extractAbbreviation(document, position) {
    let currentLine = document.lineAt(position.line).text;
    let result;
    try {
        result = extract(currentLine, position.character, true);
    }
    catch (e) {
    }
    if (!result) {
        return [null, ''];
    }
    let rangeToReplace = new vscode.Range(position.line, result.location, position.line, result.location + result.abbreviation.length);
    return [rangeToReplace, result.abbreviation];
}
exports.extractAbbreviation = extractAbbreviation;
/**
 * Returns a boolean denoting validity of given abbreviation in the context of given syntax
 * Not needed once https://github.com/emmetio/atom-plugin/issues/22 is fixed
 * @param syntax string
 * @param abbreviation string
 */
function isAbbreviationValid(syntax, abbreviation) {
    return !isStyleSheet(syntax) ? (htmlAbbreviationStartRegex.test(abbreviation) && htmlAbbreviationEndRegex.test(abbreviation)) : cssAbbreviationRegex.test(abbreviation);
}
exports.isAbbreviationValid = isAbbreviationValid;
/**
 * Returns options to be used by the expand module
 * @param syntax
 * @param textToReplace
 */
function getExpandOptions(syntax, textToReplace) {
    return {
        field: field,
        syntax: syntax,
        profile: getProfile(syntax),
        addons: syntax === 'jsx' ? { 'jsx': true } : null,
        variables: getVariables(),
        text: textToReplace ? textToReplace : null
    };
}
exports.getExpandOptions = getExpandOptions;
/**
 * Maps and returns syntaxProfiles of previous format to ones compatible with new emmet modules
 * @param syntax
 */
function getProfile(syntax) {
    let profilesFromSettings = vscode.workspace.getConfiguration('emmet')['syntaxProfiles'] || {};
    let profilesConfig = Object.assign({}, profilesFromFile, profilesFromSettings);
    let options = profilesConfig[syntax];
    if (!options || typeof options === 'string') {
        if (options === 'xhtml') {
            return {
                selfClosingStyle: 'xhtml'
            };
        }
        return {};
    }
    let newOptions = {};
    for (let key in options) {
        switch (key) {
            case 'tag_case':
                newOptions['tagCase'] = (options[key] === 'lower' || options[key] === 'upper') ? options[key] : '';
                break;
            case 'attr_case':
                newOptions['attributeCase'] = (options[key] === 'lower' || options[key] === 'upper') ? options[key] : '';
                break;
            case 'attr_quotes':
                newOptions['attributeQuotes'] = options[key];
                break;
            case 'tag_nl':
                newOptions['format'] = (options[key] === 'true' || options[key] === 'false') ? options[key] : 'true';
                break;
            case 'indent':
                newOptions['attrCase'] = (options[key] === 'true' || options[key] === 'false') ? '\t' : options[key];
                break;
            case 'inline_break':
                newOptions['inlineBreak'] = options[key];
                break;
            case 'self_closing_tag':
                if (options[key] === true) {
                    newOptions['selfClosingStyle'] = 'xml';
                    break;
                }
                if (options[key] === false) {
                    newOptions['selfClosingStyle'] = 'html';
                    break;
                }
                newOptions['selfClosingStyle'] = options[key];
                break;
            default:
                newOptions[key] = options[key];
                break;
        }
    }
    return newOptions;
}
exports.getProfile = getProfile;
/**
 * Returns variables to be used while expanding snippets
 */
function getVariables() {
    let variablesFromSettings = vscode.workspace.getConfiguration('emmet')['variables'];
    return Object.assign({}, variablesFromFile, variablesFromSettings);
}
exports.getVariables = getVariables;
/**
 * Updates customizations from snippets.json and syntaxProfiles.json files in the directory configured in emmet.extensionsPath setting
 */
function updateExtensionsPath() {
    let currentEmmetExtensionsPath = vscode.workspace.getConfiguration('emmet')['extensionsPath'];
    if (emmetExtensionsPath !== currentEmmetExtensionsPath) {
        emmetExtensionsPath = currentEmmetExtensionsPath;
        if (emmetExtensionsPath && emmetExtensionsPath.trim()) {
            let dirPath = path.isAbsolute(emmetExtensionsPath) ? emmetExtensionsPath : path.join(vscode.workspace.rootPath, emmetExtensionsPath);
            let snippetsPath = path.join(dirPath, 'snippets.json');
            let profilesPath = path.join(dirPath, 'syntaxProfiles.json');
            if (dirExists(dirPath)) {
                fs.readFile(snippetsPath, (err, snippetsData) => {
                    if (err) {
                        return;
                    }
                    try {
                        let snippetsJson = JSON.parse(snippetsData.toString());
                        variablesFromFile = snippetsJson['variables'];
                    }
                    catch (e) {
                    }
                });
                fs.readFile(profilesPath, (err, profilesData) => {
                    if (err) {
                        return;
                    }
                    try {
                        profilesFromFile = JSON.parse(profilesData.toString());
                    }
                    catch (e) {
                    }
                });
            }
        }
    }
}
exports.updateExtensionsPath = updateExtensionsPath;
function dirExists(dirPath) {
    try {
        return fs.statSync(dirPath).isDirectory();
    }
    catch (e) {
        return false;
    }
}
/**
* Get the corresponding emmet mode for given vscode language mode
* Eg: jsx for typescriptreact/javascriptreact or pug for jade
* If the language is not supported by emmet or has been exlcuded via `exlcudeLanguages` setting,
* then nothing is returned
*
* @param language
*/
function getEmmetMode(language) {
    const excludedConfig = vscode.workspace.getConfiguration('emmet')['excludeLanguages'];
    const excludedLanguages = Array.isArray(excludedConfig) ? excludedConfig : [];
    if (!language || excludedLanguages.indexOf(language) > -1) {
        return;
    }
    if (/\b(typescriptreact|javascriptreact|jsx-tags)\b/.test(language)) {
        return 'jsx';
    }
    if (language === 'sass-indented') {
        return 'sass';
    }
    if (language === 'jade') {
        return 'pug';
    }
    if (emmetModes.indexOf(language) > -1) {
        return language;
    }
}
exports.getEmmetMode = getEmmetMode;
