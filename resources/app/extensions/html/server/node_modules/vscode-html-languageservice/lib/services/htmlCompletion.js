(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", '../parser/htmlScanner', '../parser/htmlTags', '../parser/razorTags'], factory);
    }
})(function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var htmlScanner_1 = require('../parser/htmlScanner');
    var htmlTags_1 = require('../parser/htmlTags');
    var razorTags_1 = require('../parser/razorTags');
    var allTagProviders = [
        htmlTags_1.getHTML5TagProvider(),
        htmlTags_1.getAngularTagProvider(),
        htmlTags_1.getIonicTagProvider(),
        razorTags_1.getRazorTagProvider()
    ];
    function doComplete(document, position, htmlDocument, settings) {
        var result = {
            isIncomplete: false,
            items: []
        };
        var tagProviders = allTagProviders.filter(function (p) { return p.isApplicable(document.languageId) && (!settings || !!settings[p.getId()]); });
        var offset = document.offsetAt(position);
        var node = htmlDocument.findNodeBefore(offset);
        if (!node) {
            return result;
        }
        var scanner = htmlScanner_1.createScanner(document.getText(), node.start);
        var currentTag;
        var currentAttributeName;
        function getReplaceRange(replaceStart) {
            if (replaceStart > offset) {
                replaceStart = offset;
            }
            return { start: document.positionAt(replaceStart), end: document.positionAt(offset) };
        }
        function collectOpenTagSuggestions(afterOpenBracket) {
            var range = getReplaceRange(afterOpenBracket);
            tagProviders.forEach(function (provider) {
                provider.collectTags(function (tag, label) {
                    result.items.push({
                        label: tag,
                        kind: 10 /* Property */,
                        documentation: label,
                        textEdit: { newText: tag, range: range }
                    });
                });
            });
            return result;
        }
        function getLineIndent(offset) {
            var text = document.getText();
            var start = offset;
            while (start > 0) {
                var ch = text.charAt(start - 1);
                if ("\n\r".indexOf(ch) >= 0) {
                    return text.substring(start, offset);
                }
                if (!isWhiteSpace(ch)) {
                    return null;
                }
                start--;
            }
            return text.substring(0, offset);
        }
        function collectCloseTagSuggestions(afterOpenBracket, matchingOnly) {
            var range = getReplaceRange(afterOpenBracket);
            var contentAfter = document.getText().substr(offset);
            var closeTag = contentAfter.match(/^\s*>/) ? '' : '>';
            var curr = node;
            while (curr) {
                var tag = curr.tag;
                if (tag && !curr.closed) {
                    var item = {
                        label: '/' + tag,
                        kind: 10 /* Property */,
                        filterText: '/' + tag + closeTag,
                        textEdit: { newText: '/' + tag + closeTag, range: range }
                    };
                    var startIndent = getLineIndent(curr.start);
                    var endIndent = getLineIndent(afterOpenBracket - 1);
                    if (startIndent !== null && endIndent !== null && startIndent !== endIndent) {
                        item.textEdit = { newText: startIndent + '</' + tag + closeTag, range: getReplaceRange(afterOpenBracket - 1 - endIndent.length) };
                        item.filterText = endIndent + '</' + tag + closeTag;
                    }
                    result.items.push(item);
                    return result;
                }
                curr = curr.parent;
            }
            if (matchingOnly) {
                return result;
            }
            tagProviders.forEach(function (provider) {
                provider.collectTags(function (tag, label) {
                    result.items.push({
                        label: '/' + tag,
                        kind: 10 /* Property */,
                        documentation: label,
                        filterText: '/' + tag + closeTag,
                        textEdit: { newText: '/' + tag + closeTag, range: range }
                    });
                });
            });
            return result;
        }
        function collectTagSuggestions(tagStart) {
            collectOpenTagSuggestions(tagStart);
            collectCloseTagSuggestions(tagStart, true);
            return result;
        }
        function collectAttributeNameSuggestions(nameStart) {
            var range = getReplaceRange(nameStart);
            tagProviders.forEach(function (provider) {
                provider.collectAttributes(currentTag, function (attribute, type) {
                    var codeSnippet = attribute;
                    if (type !== 'v') {
                        codeSnippet = codeSnippet + '="{{}}"';
                    }
                    result.items.push({
                        label: attribute,
                        kind: type === 'handler' ? 3 /* Function */ : 12 /* Value */,
                        textEdit: { newText: codeSnippet, range: range }
                    });
                });
            });
            return result;
        }
        function collectAttributeValueSuggestions(valueStart) {
            var range = getReplaceRange(valueStart);
            tagProviders.forEach(function (provider) {
                provider.collectValues(currentTag, currentAttributeName, function (value) {
                    var codeSnippet = '"' + value + '"';
                    result.items.push({
                        label: value,
                        filterText: codeSnippet,
                        kind: 11 /* Unit */,
                        textEdit: { newText: codeSnippet, range: range }
                    });
                });
            });
            return result;
        }
        var token = scanner.scan();
        while (token !== htmlScanner_1.TokenType.EOS && scanner.getTokenOffset() <= offset) {
            switch (token) {
                case htmlScanner_1.TokenType.StartTagOpen:
                    if (scanner.getTokenEnd() === offset) {
                        return collectTagSuggestions(offset);
                    }
                    break;
                case htmlScanner_1.TokenType.StartTag:
                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {
                        return collectOpenTagSuggestions(scanner.getTokenOffset());
                    }
                    currentTag = scanner.getTokenText();
                    break;
                case htmlScanner_1.TokenType.AttributeName:
                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {
                        return collectAttributeNameSuggestions(scanner.getTokenOffset());
                    }
                    currentAttributeName = scanner.getTokenText();
                    break;
                case htmlScanner_1.TokenType.DelimiterAssign:
                    if (scanner.getTokenEnd() === offset) {
                        return collectAttributeValueSuggestions(scanner.getTokenEnd());
                    }
                    break;
                case htmlScanner_1.TokenType.AttributeValue:
                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {
                        return collectAttributeValueSuggestions(scanner.getTokenOffset());
                    }
                    break;
                case htmlScanner_1.TokenType.Whitespace:
                    if (offset <= scanner.getTokenEnd()) {
                        switch (scanner.getScannerState()) {
                            case htmlScanner_1.ScannerState.AfterOpeningStartTag:
                                return collectTagSuggestions(scanner.getTokenOffset());
                            case htmlScanner_1.ScannerState.WithinTag:
                            case htmlScanner_1.ScannerState.AfterAttributeName:
                                return collectAttributeNameSuggestions(scanner.getTokenEnd());
                            case htmlScanner_1.ScannerState.BeforeAttributeValue:
                                return collectAttributeValueSuggestions(scanner.getTokenEnd());
                            case htmlScanner_1.ScannerState.AfterOpeningEndTag:
                                return collectCloseTagSuggestions(scanner.getTokenOffset() - 1, false);
                        }
                    }
                    break;
                case htmlScanner_1.TokenType.EndTagOpen:
                    if (offset <= scanner.getTokenEnd()) {
                        return collectCloseTagSuggestions(scanner.getTokenOffset() + 1, false);
                    }
                    break;
                case htmlScanner_1.TokenType.EndTag:
                    if (offset <= scanner.getTokenEnd()) {
                        var text = document.getText();
                        var start = scanner.getTokenOffset() - 1;
                        while (start >= 0) {
                            var ch = text.charAt(start);
                            if (ch === '/') {
                                return collectCloseTagSuggestions(start, false);
                            }
                            else if (!isWhiteSpace(ch)) {
                                break;
                            }
                            start--;
                        }
                    }
                    break;
                default:
                    if (offset <= scanner.getTokenEnd()) {
                        return result;
                    }
                    break;
            }
            token = scanner.scan();
        }
        return result;
    }
    exports.doComplete = doComplete;
    function isWhiteSpace(s) {
        return /^\s*$/.test(s);
    }
});
//# sourceMappingURL=htmlCompletion.js.map