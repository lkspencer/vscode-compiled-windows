/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var path = require('path');
var baseSourceMapTransformer_1 = require('./baseSourceMapTransformer');
var utils = require('../utils');
var logger = require('../logger');
/**
 * Load SourceMaps on launch. Requires reading the file and parsing out the sourceMappingURL, because
 * if you wait until the script is loaded as in LazySMT, you get that info from the runtime.
 */
var EagerSourceMapTransformer = (function (_super) {
    __extends(EagerSourceMapTransformer, _super);
    function EagerSourceMapTransformer() {
        _super.apply(this, arguments);
    }
    EagerSourceMapTransformer.prototype.init = function (args) {
        var _this = this;
        _super.prototype.init.call(this, args);
        if (args.sourceMaps) {
            var generatedCodeGlobs = args.outFiles ?
                args.outFiles :
                args.outDir ?
                    [path.join(args.outDir, '**/*.js')] :
                    [];
            // try to find all source files upfront asynchronously
            if (generatedCodeGlobs.length > 0) {
                logger.log('SourceMaps: preloading sourcemaps for scripts in globs: ' + JSON.stringify(generatedCodeGlobs));
                this._preLoad = utils.multiGlob(generatedCodeGlobs)
                    .then(function (paths) {
                    logger.log("SourceMaps: expanded globs and found " + paths.length + " scripts");
                    return Promise.all(paths.map(function (scriptPath) { return _this.discoverSourceMapForGeneratedScript(scriptPath); }));
                })
                    .then(function () { });
            }
            else {
                this._preLoad = Promise.resolve();
            }
        }
    };
    EagerSourceMapTransformer.prototype.discoverSourceMapForGeneratedScript = function (generatedScriptPath) {
        var _this = this;
        return this.findSourceMapUrlInFile(generatedScriptPath)
            .then(function (uri) {
            if (uri) {
                logger.log("SourceMaps: sourcemap url parsed from end of generated content: " + uri);
                return _this._sourceMaps.processNewSourceMap(generatedScriptPath, uri);
            }
            else {
                logger.log("SourceMaps: no sourcemap url found in generated script: " + generatedScriptPath);
                return undefined;
            }
        })
            .catch(function (err) {
            // If we fail to preload one, ignore and keep going
            logger.log("SourceMaps: could not preload for generated script: " + generatedScriptPath + ". Error: " + err.toString());
        });
    };
    /**
     * Try to find the 'sourceMappingURL' in content or the file with the given path.
     * Returns null if no source map url is found or if an error occured.
     */
    EagerSourceMapTransformer.prototype.findSourceMapUrlInFile = function (pathToGenerated, content) {
        var _this = this;
        if (content) {
            return Promise.resolve(this.findSourceMapUrl(content));
        }
        return utils.readFileP(pathToGenerated)
            .then(function (fileContents) { return _this.findSourceMapUrl(fileContents); });
    };
    /**
     * Try to find the 'sourceMappingURL' at the end of the given contents.
     * Relative file paths are converted into absolute paths.
     * Returns null if no source map url is found.
     */
    EagerSourceMapTransformer.prototype.findSourceMapUrl = function (contents) {
        var lines = contents.split('\n');
        for (var l = lines.length - 1; l >= Math.max(lines.length - 10, 0); l--) {
            var line = lines[l].trim();
            var matches = EagerSourceMapTransformer.SOURCE_MAPPING_MATCHER.exec(line);
            if (matches && matches.length === 2) {
                return matches[1].trim();
            }
        }
        return null;
    };
    EagerSourceMapTransformer.SOURCE_MAPPING_MATCHER = new RegExp('^//[#@] ?sourceMappingURL=(.+)$');
    return EagerSourceMapTransformer;
}(baseSourceMapTransformer_1.BaseSourceMapTransformer));
exports.EagerSourceMapTransformer = EagerSourceMapTransformer;

//# sourceMappingURL=eagerSourceMapTransformer.js.map
