/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var WebSocket = require('ws');
var events_1 = require('events');
var errors = require('../errors');
var utils = require('../utils');
var logger = require('../logger');
var chromeTargetDiscoveryStrategy_1 = require('./chromeTargetDiscoveryStrategy');
/**
 * Implements a Request/Response API on top of a WebSocket for messages that are marked with an `id` property.
 * Emits `message.method` for messages that don't have `id`.
 */
var ResReqWebSocket = (function (_super) {
    __extends(ResReqWebSocket, _super);
    function ResReqWebSocket() {
        _super.apply(this, arguments);
        this._pendingRequests = new Map();
    }
    Object.defineProperty(ResReqWebSocket.prototype, "isOpen", {
        get: function () { return !!this._wsAttached; },
        enumerable: true,
        configurable: true
    });
    /**
     * Attach to the given websocket url
     */
    ResReqWebSocket.prototype.open = function (wsUrl) {
        var _this = this;
        this._wsAttached = new Promise(function (resolve, reject) {
            var ws;
            try {
                ws = new WebSocket(wsUrl);
            }
            catch (e) {
                // invalid url e.g.
                reject(e.message);
                return;
            }
            // WebSocket will try to connect for 20+ seconds before timing out.
            // Implement a shorter timeout here
            setTimeout(function () { return reject('WebSocket connection timed out'); }, 10000);
            // if 'error' is fired while connecting, reject the promise
            ws.on('error', reject);
            ws.on('open', function () {
                // Replace the promise-rejecting handler
                ws.removeListener('error', reject);
                ws.on('error', function (e) {
                    logger.log('Websocket error: ' + e.toString());
                    _this.emit('error', e);
                });
                resolve(ws);
            });
            ws.on('message', function (msgStr) {
                var msgObj = JSON.parse(msgStr);
                if (msgObj
                    && !(msgObj.method === 'Debugger.scriptParsed' && msgObj.params && msgObj.params.isContentScript)
                    && !(msgObj.params && msgObj.params.url && msgObj.params.url.indexOf('extensions::') === 0)) {
                    // Not really the right place to examine the content of the message, but don't log annoying extension script notifications.
                    logger.verbose('From target: ' + msgStr);
                }
                _this.onMessage(msgObj);
            });
            ws.on('close', function () {
                logger.log('Websocket closed');
                _this.emit('close');
            });
        });
        return this._wsAttached.then(function () { });
    };
    ResReqWebSocket.prototype.close = function () {
        if (this._wsAttached) {
            this._wsAttached.then(function (ws) { return ws.close(); });
            this._wsAttached = null;
        }
    };
    /**
     * Send a message which must have an id. Ok to call immediately after attach. Messages will be queued until
     * the websocket actually attaches.
     */
    ResReqWebSocket.prototype.sendMessage = function (message) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._pendingRequests.set(message.id, resolve);
            _this._wsAttached.then(function (ws) {
                var msgStr = JSON.stringify(message);
                logger.verbose('To target: ' + msgStr);
                ws.send(msgStr);
            });
        });
    };
    /**
     * Wrap EventEmitter.emit in try/catch and log, for errors thrown in subscribers
     */
    ResReqWebSocket.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        try {
            return _super.prototype.emit.apply(this, arguments);
        }
        catch (e) {
            logger.error('Error while handling target event: ' + e.stack);
            return false;
        }
    };
    ResReqWebSocket.prototype.onMessage = function (message) {
        if (typeof message.id === 'number') {
            if (this._pendingRequests.has(message.id)) {
                // Resolve the pending request with this response
                this._pendingRequests.get(message.id)(message);
                this._pendingRequests.delete(message.id);
            }
            else {
                logger.error("Got a response with id " + message.id + " for which there is no pending request.");
            }
        }
        else if (message.method) {
            this.emit(message.method, message.params);
        }
        else {
            // Message is malformed - safely stringify and log it
            var messageStr = void 0;
            try {
                messageStr = JSON.stringify(message);
            }
            catch (e) {
                messageStr = '' + message;
            }
            logger.error("Got a response with no id nor method property: " + messageStr);
        }
    };
    return ResReqWebSocket;
}(events_1.EventEmitter));
/**
 * Connects to a target supporting the Chrome Debug Protocol and sends and receives messages
 */
var ChromeConnection = (function () {
    function ChromeConnection(targetDiscovery, targetFilter) {
        this._targetFilter = targetFilter;
        this._targetDiscoveryStrategy = targetDiscovery || chromeTargetDiscoveryStrategy_1.getChromeTargetWebSocketURL;
        // this._socket should exist before attaching so consumers can call on() before attach, which fires events
        this.reset();
    }
    Object.defineProperty(ChromeConnection.prototype, "isAttached", {
        get: function () { return this._socket.isOpen; },
        enumerable: true,
        configurable: true
    });
    ChromeConnection.prototype.on = function (eventName, handler) {
        this._socket.on(eventName, handler);
    };
    /**
     * Attach the websocket to the first available tab in the chrome instance with the given remote debugging port number.
     */
    ChromeConnection.prototype.attach = function (address, port, targetUrl) {
        var _this = this;
        if (address === void 0) { address = '127.0.0.1'; }
        if (port === void 0) { port = 9222; }
        return this._attach(address, port, targetUrl)
            .then(function () { return Promise.all([
            _this.sendMessage('Runtime.enable'),
            _this.sendMessage('Debugger.enable'),
            _this.sendMessage('Console.enable'),
            _this.run()]); })
            .then(function () { });
    };
    ChromeConnection.prototype._attach = function (address, port, targetUrl, timeout) {
        var _this = this;
        if (timeout === void 0) { timeout = ChromeConnection.ATTACH_TIMEOUT; }
        return utils.retryAsync(function () { return _this._targetDiscoveryStrategy(address, port, _this._targetFilter, targetUrl); }, timeout, /*intervalDelay=*/ 200)
            .catch(function (err) { return Promise.reject(errors.runtimeConnectionTimeout(timeout, err.message)); })
            .then(function (wsUrl) { return _this._socket.open(wsUrl); });
    };
    ChromeConnection.prototype.run = function () {
        // This is a CDP version difference which will have to be handled more elegantly with others later...
        // For now, we need to send both messages and ignore a failing one.
        return Promise.all([
            this.runtime_runIfWaitingForDebugger(),
            this.runtime_run()
        ])
            .then(function () { }, function (e) { });
    };
    ChromeConnection.prototype.close = function () {
        this._socket.close();
        this.reset();
    };
    ChromeConnection.prototype.reset = function () {
        this._nextId = 1;
        this._socket = new ResReqWebSocket();
    };
    ChromeConnection.prototype.debugger_setBreakpoint = function (location, condition) {
        return this.sendMessage('Debugger.setBreakpoint', { location: location, condition: condition });
    };
    ChromeConnection.prototype.debugger_setBreakpointByUrlRegex = function (urlRegex, lineNumber, columnNumber, condition) {
        return this.sendMessage('Debugger.setBreakpointByUrl', { urlRegex: urlRegex, lineNumber: lineNumber, columnNumber: columnNumber, condition: condition });
    };
    ChromeConnection.prototype.debugger_removeBreakpoint = function (breakpointId) {
        return this.sendMessage('Debugger.removeBreakpoint', { breakpointId: breakpointId });
    };
    ChromeConnection.prototype.debugger_stepOver = function () {
        return this.sendMessage('Debugger.stepOver');
    };
    ChromeConnection.prototype.debugger_stepIn = function () {
        return this.sendMessage('Debugger.stepInto');
    };
    ChromeConnection.prototype.debugger_stepOut = function () {
        return this.sendMessage('Debugger.stepOut');
    };
    ChromeConnection.prototype.debugger_resume = function () {
        return this.sendMessage('Debugger.resume');
    };
    ChromeConnection.prototype.debugger_pause = function () {
        return this.sendMessage('Debugger.pause');
    };
    ChromeConnection.prototype.debugger_evaluateOnCallFrame = function (callFrameId, expression, objectGroup, returnByValue, silent) {
        if (objectGroup === void 0) { objectGroup = 'dummyObjectGroup'; }
        return this.sendMessage('Debugger.evaluateOnCallFrame', { callFrameId: callFrameId, expression: expression, objectGroup: objectGroup, returnByValue: returnByValue, silent: silent });
    };
    ChromeConnection.prototype.debugger_setPauseOnExceptions = function (state) {
        return this.sendMessage('Debugger.setPauseOnExceptions', { state: state });
    };
    ChromeConnection.prototype.debugger_getScriptSource = function (scriptId) {
        return this.sendMessage('Debugger.getScriptSource', { scriptId: scriptId });
    };
    ChromeConnection.prototype.debugger_setVariableValue = function (callFrameId, scopeNumber, variableName, newValue) {
        return this.sendMessage('Debugger.setVariableValue', { callFrameId: callFrameId, scopeNumber: scopeNumber, variableName: variableName, newValue: newValue });
    };
    ChromeConnection.prototype.runtime_getProperties = function (objectId, ownProperties, accessorPropertiesOnly, generatePreview) {
        return this.sendMessage('Runtime.getProperties', { objectId: objectId, ownProperties: ownProperties, accessorPropertiesOnly: accessorPropertiesOnly, generatePreview: generatePreview });
    };
    ChromeConnection.prototype.runtime_evaluate = function (expression, objectGroup, contextId, returnByValue, silent) {
        if (contextId === void 0) { contextId = 1; }
        if (returnByValue === void 0) { returnByValue = false; }
        return this.sendMessage('Runtime.evaluate', { expression: expression, objectGroup: objectGroup, contextId: contextId, returnByValue: returnByValue, silent: silent });
    };
    ChromeConnection.prototype.runtime_callFunctionOn = function (objectId, functionDeclaration, args, silent, returnByValue, generatePreview, userGesture, awaitPromise) {
        return this.sendMessage('Runtime.callFunctionOn', { objectId: objectId, functionDeclaration: functionDeclaration, arguments: args, silent: silent, returnByValue: returnByValue, generatePreview: generatePreview, userGesture: userGesture, awaitPromise: awaitPromise });
    };
    ChromeConnection.prototype.runtime_runIfWaitingForDebugger = function () {
        return this.sendMessage('Runtime.runIfWaitingForDebugger');
    };
    ChromeConnection.prototype.runtime_run = function () {
        return this.sendMessage('Runtime.run');
    };
    ChromeConnection.prototype.page_setOverlayMessage = function (message) {
        return this.sendMessage('Page.setOverlayMessage', { message: message });
    };
    ChromeConnection.prototype.page_clearOverlayMessage = function () {
        return this.sendMessage('Page.setOverlayMessage');
    };
    ChromeConnection.prototype.emulation_clearDeviceMetricsOverride = function () {
        return this.sendMessage('Emulation.clearDeviceMetricsOverride');
    };
    ChromeConnection.prototype.emulation_setEmulatedMedia = function (media) {
        return this.sendMessage('Emulation.setEmulatedMedia', { media: media });
    };
    ChromeConnection.prototype.emulation_setTouchEmulationEnabled = function (enabled, configuration) {
        var messageData = { enabled: enabled };
        if (configuration) {
            messageData.configuration = configuration;
        }
        return this.sendMessage('Emulation.setTouchEmulationEnabled', messageData);
    };
    ChromeConnection.prototype.emulation_resetScrollAndPageScaleFactor = function () {
        return this.sendMessage('Emulation.resetScrollAndPageScaleFactor');
    };
    ChromeConnection.prototype.emulation_setDeviceMetricsOverride = function (metrics) {
        return this.sendMessage('Emulation.setDeviceMetricsOverride', metrics);
    };
    ChromeConnection.prototype.sendMessage = function (method, params) {
        return this._socket.sendMessage({
            id: this._nextId++,
            method: method,
            params: params
        });
    };
    ChromeConnection.ATTACH_TIMEOUT = 10000; // ms
    return ChromeConnection;
}());
exports.ChromeConnection = ChromeConnection;

//# sourceMappingURL=chromeConnection.js.map
