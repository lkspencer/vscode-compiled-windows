/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var os = require('os');
var fs = require('fs');
var url = require('url');
var path = require('path');
var glob = require('glob');
var vscode_debugadapter_1 = require('vscode-debugadapter');
var xhr = require('request-light');
var logger = require('./logger');
function getPlatform() {
    var platform = os.platform();
    return platform === 'darwin' ? 1 /* OSX */ :
        platform === 'win32' ? 0 /* Windows */ :
            2 /* Linux */;
}
exports.getPlatform = getPlatform;
/**
 * Node's fs.existsSync is deprecated, implement it in terms of statSync
 */
function existsSync(path) {
    try {
        fs.statSync(path);
        return true;
    }
    catch (e) {
        // doesn't exist
        return false;
    }
}
exports.existsSync = existsSync;
var DebounceHelper = (function () {
    function DebounceHelper(timeoutMs) {
        this.timeoutMs = timeoutMs;
    }
    /**
     * If not waiting already, call fn after the timeout
     */
    DebounceHelper.prototype.wait = function (fn) {
        var _this = this;
        if (!this.waitToken) {
            this.waitToken = setTimeout(function () {
                _this.waitToken = null;
                fn();
            }, this.timeoutMs);
        }
    };
    /**
     * If waiting for something, cancel it and call fn immediately
     */
    DebounceHelper.prototype.doAndCancel = function (fn) {
        if (this.waitToken) {
            clearTimeout(this.waitToken);
            this.waitToken = null;
        }
        fn();
    };
    return DebounceHelper;
}());
exports.DebounceHelper = DebounceHelper;
/**
 * Returns a reversed version of arr. Doesn't modify the input.
 */
function reversedArr(arr) {
    return arr.reduce(function (reversed, x) {
        reversed.unshift(x);
        return reversed;
    }, []);
}
exports.reversedArr = reversedArr;
function promiseTimeout(p, timeoutMs, timeoutMsg) {
    if (timeoutMs === void 0) { timeoutMs = 1000; }
    if (timeoutMsg === undefined) {
        timeoutMsg = "Promise timed out after " + timeoutMs + "ms";
    }
    return new Promise(function (resolve, reject) {
        if (p) {
            p.then(resolve, reject);
        }
        setTimeout(function () {
            if (p) {
                reject(new Error(timeoutMsg));
            }
            else {
                resolve();
            }
        }, timeoutMs);
    });
}
exports.promiseTimeout = promiseTimeout;
function retryAsync(fn, timeoutMs, intervalDelay) {
    if (intervalDelay === void 0) { intervalDelay = 0; }
    var startTime = Date.now();
    function tryUntilTimeout() {
        return fn().catch(function (e) {
            if (Date.now() - startTime < (timeoutMs - intervalDelay)) {
                return promiseTimeout(null, intervalDelay).then(tryUntilTimeout);
            }
            else {
                return errP(e);
            }
        });
    }
    return tryUntilTimeout();
}
exports.retryAsync = retryAsync;
/**
 * Modify a url/path either from the client or the target to a common format for comparing.
 * The client can handle urls in this format too.
 * file:///D:\\scripts\\code.js => d:/scripts/code.js
 * file:///Users/me/project/code.js => /Users/me/project/code.js
 * c:/scripts/code.js => c:\\scripts\\code.js
 * http://site.com/scripts/code.js => (no change)
 * http://site.com/ => http://site.com
 */
function canonicalizeUrl(urlOrPath) {
    urlOrPath = fileUrlToPath(urlOrPath);
    // Remove query params
    if (urlOrPath.indexOf('?') >= 0) {
        urlOrPath = urlOrPath.split('?')[0];
    }
    urlOrPath = stripTrailingSlash(urlOrPath);
    urlOrPath = fixDriveLetterAndSlashes(urlOrPath);
    return urlOrPath;
}
exports.canonicalizeUrl = canonicalizeUrl;
/**
 * If urlOrPath is a file URL, removes the 'file:///', adjusting for platform differences
 */
function fileUrlToPath(urlOrPath) {
    if (urlOrPath.startsWith('file:///')) {
        urlOrPath = urlOrPath.replace('file:///', '');
        urlOrPath = decodeURIComponent(urlOrPath);
        if (urlOrPath[0] !== '/' && urlOrPath.indexOf(':') < 0) {
            // Ensure unix-style path starts with /, it can be removed when file:/// was stripped.
            // Don't add if the url still has a protocol
            urlOrPath = '/' + urlOrPath;
        }
        urlOrPath = fixDriveLetterAndSlashes(urlOrPath);
    }
    return urlOrPath;
}
exports.fileUrlToPath = fileUrlToPath;
/**
 * Replace any backslashes with forward slashes
 * blah\something => blah/something
 */
function forceForwardSlashes(aUrl) {
    return aUrl.replace(/\\/g, '/');
}
exports.forceForwardSlashes = forceForwardSlashes;
/**
 * Ensure lower case drive letter and \ on Windows
 */
function fixDriveLetterAndSlashes(aPath, uppercaseDriveLetter) {
    if (uppercaseDriveLetter === void 0) { uppercaseDriveLetter = false; }
    if (aPath.match(/file:\/\/\/[A-Za-z]:/)) {
        var prefixLen = 'file:///'.length;
        aPath =
            'file:///' +
                aPath[prefixLen].toLowerCase() +
                aPath.substr(prefixLen + 1).replace(/\//g, path.sep);
    }
    else if (aPath.match(/^[A-Za-z]:/)) {
        // If the path starts with a drive letter, ensure lowercase. VS Code uses a lowercase drive letter
        var driveLetter = uppercaseDriveLetter ? aPath[0].toUpperCase() : aPath[0].toLowerCase();
        aPath = driveLetter + aPath.substr(1);
        aPath = aPath.replace(/\//g, '\\');
    }
    return aPath;
}
exports.fixDriveLetterAndSlashes = fixDriveLetterAndSlashes;
/**
 * Remove a slash of any flavor from the end of the path
 */
function stripTrailingSlash(aPath) {
    return aPath
        .replace(/\/$/, '')
        .replace(/\\$/, '');
}
exports.stripTrailingSlash = stripTrailingSlash;
/**
 * A helper for returning a rejected promise with an Error object. Avoids double-wrapping an Error, which could happen
 * when passing on a failure from a Promise error handler.
 * @param msg - Should be either a string or an Error
 */
function errP(msg) {
    var isErrorLike = function (thing) { return !!thing.message; };
    var e;
    if (!msg) {
        e = new Error('Unknown error');
    }
    else if (isErrorLike(msg)) {
        // msg is already an Error object
        e = msg;
    }
    else {
        e = new Error(msg);
    }
    return Promise.reject(e);
}
exports.errP = errP;
/**
 * Helper function to GET the contents of a url
 */
function getURL(aUrl) {
    var options = {
        url: aUrl,
        followRedirects: 5
    };
    return xhr.xhr(options)
        .then(function (xhrResponse) { return xhrResponse.responseText; })
        .catch(function (e) {
        var errMsg = typeof e.status === 'number' ?
            e.status + ' - ' + xhr.getErrorStatusDescription(e.status) :
            e.toString();
        logger.log('HTTP - GET failed with: ' + errMsg);
        return errP(errMsg);
    });
}
exports.getURL = getURL;
/**
 * Returns true if urlOrPath is like "http://localhost" and not like "c:/code/file.js" or "/code/file.js"
 */
function isURL(urlOrPath) {
    return urlOrPath && !path.isAbsolute(urlOrPath) && !!url.parse(urlOrPath).protocol;
}
exports.isURL = isURL;
/**
 * Strip a string from the left side of a string
 */
function lstrip(s, lStr) {
    return s.startsWith(lStr) ?
        s.substr(lStr.length) :
        s;
}
exports.lstrip = lstrip;
/**
 * Convert a local path to a file URL, like
 * C:/code/app.js => file:///C:/code/app.js
 * /code/app.js => file:///code/app.js
 */
function pathToFileURL(absPath) {
    absPath = forceForwardSlashes(absPath);
    absPath = (absPath.startsWith('/') ? 'file://' : 'file:///') +
        absPath;
    return encodeURI(absPath);
}
exports.pathToFileURL = pathToFileURL;
/**
 * Placeholder localize function
 */
function localize(idOrInfo, msg) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    args.forEach(function (arg, i) {
        msg = msg.replace(new RegExp("\\{" + i + "\\}", 'g'), arg);
    });
    return msg;
}
exports.localize = localize;
function fsReadDirP(path) {
    return new Promise(function (resolve, reject) {
        fs.readdir(path, function (err, files) {
            if (err) {
                reject(err);
            }
            else {
                resolve(files);
            }
        });
    });
}
exports.fsReadDirP = fsReadDirP;
function readFileP(path, encoding) {
    if (encoding === void 0) { encoding = 'utf8'; }
    return new Promise(function (resolve, reject) {
        fs.readFile(path, encoding, function (err, fileContents) {
            if (err) {
                reject(err);
            }
            else {
                resolve(fileContents);
            }
        });
    });
}
exports.readFileP = readFileP;
function writeFileP(filePath, data) {
    return new Promise(function (resolve, reject) {
        mkdirs(path.dirname(filePath));
        fs.writeFile(filePath, data, function (err) {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
}
exports.writeFileP = writeFileP;
/**
 * Make sure that all directories of the given path exist (like mkdir -p).
 */
function mkdirs(dirsPath) {
    if (!fs.existsSync(dirsPath)) {
        mkdirs(path.dirname(dirsPath));
        fs.mkdirSync(dirsPath);
    }
}
exports.mkdirs = mkdirs;
// ---- globbing support -------------------------------------------------
function extendObject(objectCopy, object) {
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            objectCopy[key] = object[key];
        }
    }
    return objectCopy;
}
exports.extendObject = extendObject;
function isExclude(pattern) {
    return pattern[0] === '!';
}
function multiGlob(patterns, opts) {
    var globTasks = [];
    opts = extendObject({
        cache: Object.create(null),
        statCache: Object.create(null),
        realpathCache: Object.create(null),
        symlinks: Object.create(null),
        ignore: []
    }, opts);
    try {
        patterns.forEach(function (pattern, i) {
            if (isExclude(pattern)) {
                return;
            }
            var ignore = patterns.slice(i).filter(isExclude).map(function (excludePattern) {
                return excludePattern.slice(1);
            });
            globTasks.push({
                pattern: pattern,
                opts: extendObject(extendObject({}, opts), {
                    ignore: opts.ignore.concat(ignore)
                })
            });
        });
    }
    catch (err) {
        return Promise.reject(err);
    }
    return Promise.all(globTasks.map(function (task) {
        return new Promise(function (c, e) {
            glob(task.pattern, task.opts, function (err, files) {
                if (err) {
                    e(err);
                }
                else {
                    c(files);
                }
            });
        });
    })).then(function (results) {
        var set = new Set();
        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
            var paths = results_1[_i];
            for (var _a = 0, paths_1 = paths; _a < paths_1.length; _a++) {
                var p = paths_1[_a];
                set.add(p);
            }
        }
        var array = [];
        set.forEach(function (v) { return array.push(fixDriveLetterAndSlashes(v)); });
        return array;
    });
}
exports.multiGlob = multiGlob;
var ReverseHandles = (function (_super) {
    __extends(ReverseHandles, _super);
    function ReverseHandles() {
        _super.apply(this, arguments);
        this._reverseMap = new Map();
    }
    ReverseHandles.prototype.create = function (value) {
        var handle = _super.prototype.create.call(this, value);
        this._reverseMap.set(value, handle);
        return handle;
    };
    ReverseHandles.prototype.lookup = function (value) {
        return this._reverseMap.get(value);
    };
    return ReverseHandles;
}(vscode_debugadapter_1.Handles));
exports.ReverseHandles = ReverseHandles;
/**
 * Return a regex for the given path to set a breakpoint on
 */
function pathToRegex(aPath) {
    aPath = aPath.replace(/([/\\.?*()^${}|[\]])/g, '\\$1');
    if (aPath.match(/^[a-zA-Z]:/)) {
        var driveLetter = aPath.charAt(0);
        var u = driveLetter.toUpperCase();
        var l = driveLetter.toLowerCase();
        aPath = "[" + u + l + "]" + aPath.substr(1);
    }
    return aPath;
}
exports.pathToRegex = pathToRegex;

//# sourceMappingURL=utils.js.map
