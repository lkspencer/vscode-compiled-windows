/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var path = require('path');
var sourceMaps_1 = require('../sourceMaps/sourceMaps');
var utils = require('../utils');
var logger = require('../logger');
/**
 * If sourcemaps are enabled, converts from source files on the client side to runtime files on the target side
 */
var BaseSourceMapTransformer = (function () {
    function BaseSourceMapTransformer(sourceHandles) {
        this._preLoad = Promise.resolve();
        this._sourceHandles = sourceHandles;
    }
    Object.defineProperty(BaseSourceMapTransformer.prototype, "sourceMaps", {
        get: function () {
            return this._sourceMaps;
        },
        enumerable: true,
        configurable: true
    });
    BaseSourceMapTransformer.prototype.launch = function (args) {
        this.init(args);
    };
    BaseSourceMapTransformer.prototype.attach = function (args) {
        this.init(args);
    };
    BaseSourceMapTransformer.prototype.init = function (args) {
        if (args.sourceMaps) {
            this._sourceMaps = new sourceMaps_1.SourceMaps(args.webRoot, args.sourceMapPathOverrides);
            this._requestSeqToSetBreakpointsArgs = new Map();
            this._allRuntimeScriptPaths = new Set();
            this._authoredPathsToMappedBPs = new Map();
        }
    };
    BaseSourceMapTransformer.prototype.clearTargetContext = function () {
        this._allRuntimeScriptPaths = new Set();
    };
    /**
     * Apply sourcemapping to the setBreakpoints request path/lines.
     * Returns true if completed successfully, and setBreakpoint should continue.
     */
    BaseSourceMapTransformer.prototype.setBreakpoints = function (args, requestSeq) {
        var _this = this;
        if (!this._sourceMaps) {
            return true;
        }
        if (args.source.sourceReference) {
            // If the source contents were inlined, then args.source has no path, but we
            // stored it in the handle
            var handle = this._sourceHandles.get(args.source.sourceReference);
            if (handle.mappedPath) {
                args.source.path = handle.mappedPath;
            }
        }
        if (args.source.path) {
            var argsPath_1 = args.source.path;
            var mappedPath_1 = this._sourceMaps.getGeneratedPathFromAuthoredPath(argsPath_1);
            if (mappedPath_1) {
                logger.log("SourceMaps.setBP: Mapped " + argsPath_1 + " to " + mappedPath_1);
                args.authoredPath = argsPath_1;
                args.source.path = mappedPath_1;
                // DebugProtocol doesn't send cols yet, but they need to be added from sourcemaps
                args.breakpoints.forEach(function (bp) {
                    var line = bp.line, _a = bp.column, column = _a === void 0 ? 0 : _a;
                    var mapped = _this._sourceMaps.mapToGenerated(argsPath_1, line, column);
                    if (mapped) {
                        logger.log("SourceMaps.setBP: Mapped " + argsPath_1 + ":" + (line + 1) + ":" + (column + 1) + " to " + mappedPath_1 + ":" + (mapped.line + 1) + ":" + (mapped.column + 1));
                        bp.line = mapped.line;
                        bp.column = mapped.column;
                    }
                    else {
                        logger.log("SourceMaps.setBP: Mapped " + argsPath_1 + " but not line " + (line + 1) + ", column 1");
                        bp.column = column; // take 0 default if needed
                    }
                });
                this._authoredPathsToMappedBPs.set(argsPath_1, args.breakpoints);
                // Include BPs from other files that map to the same file. Ensure the current file's breakpoints go first
                this._sourceMaps.allMappedSources(mappedPath_1).forEach(function (sourcePath) {
                    if (sourcePath === argsPath_1) {
                        return;
                    }
                    var sourceBPs = _this._authoredPathsToMappedBPs.get(sourcePath);
                    if (sourceBPs) {
                        // Don't modify the cached array
                        args.breakpoints = args.breakpoints.concat(sourceBPs);
                    }
                });
            }
            else if (this._allRuntimeScriptPaths.has(argsPath_1)) {
                // It's a generated file which is loaded
                logger.log("SourceMaps.setBP: SourceMaps are enabled but " + argsPath_1 + " is a runtime script");
            }
            else {
                // Source (or generated) file which is not loaded, need to wait
                logger.log("SourceMaps.setBP: " + argsPath_1 + " can't be resolved to a loaded script. It may just not be loaded yet.");
                return false;
            }
        }
        else {
        }
        this._requestSeqToSetBreakpointsArgs.set(requestSeq, JSON.parse(JSON.stringify(args)));
        return true;
    };
    /**
     * Apply sourcemapping back to authored files from the response
     */
    BaseSourceMapTransformer.prototype.setBreakpointsResponse = function (response, requestSeq) {
        var _this = this;
        if (this._sourceMaps && this._requestSeqToSetBreakpointsArgs.has(requestSeq)) {
            var args_1 = this._requestSeqToSetBreakpointsArgs.get(requestSeq);
            if (args_1.authoredPath) {
                var sourceBPs_1 = this._authoredPathsToMappedBPs.get(args_1.authoredPath);
                if (sourceBPs_1) {
                    // authoredPath is set, so the file was mapped to source.
                    // Remove breakpoints from files that map to the same file, and map back to source.
                    response.breakpoints = response.breakpoints.filter(function (_, i) { return i < sourceBPs_1.length; });
                    response.breakpoints.forEach(function (bp) {
                        var mapped = _this._sourceMaps.mapToAuthored(args_1.source.path, bp.line, bp.column);
                        if (mapped) {
                            logger.log("SourceMaps.setBP: Mapped " + args_1.source.path + ":" + (bp.line + 1) + ":" + (bp.column + 1) + " to " + mapped.source + ":" + (mapped.line + 1));
                            bp.line = mapped.line;
                            bp.column = mapped.column;
                        }
                        else {
                            logger.log("SourceMaps.setBP: Can't map " + args_1.source.path + ":" + (bp.line + 1) + ":" + (bp.column + 1) + ", keeping the line number as-is.");
                        }
                        _this._requestSeqToSetBreakpointsArgs.delete(requestSeq);
                    });
                }
            }
        }
    };
    /**
     * Apply sourcemapping to the stacktrace response
     */
    BaseSourceMapTransformer.prototype.stackTraceResponse = function (response) {
        var _this = this;
        if (this._sourceMaps) {
            response.stackFrames.forEach(function (stackFrame) {
                var mapped = _this._sourceMaps.mapToAuthored(stackFrame.source.path, stackFrame.line, stackFrame.column);
                if (mapped && utils.existsSync(mapped.source)) {
                    // Script was mapped to a valid path
                    stackFrame.source.path = mapped.source;
                    stackFrame.source.sourceReference = 0;
                    stackFrame.source.name = path.basename(mapped.source);
                    stackFrame.line = mapped.line;
                    stackFrame.column = mapped.column;
                }
                else {
                    var inlinedSource = mapped && _this._sourceMaps.sourceContentFor(mapped.source);
                    if (mapped && inlinedSource) {
                        // Clear the path and set the sourceReference - the client will ask for
                        // the source later and it will be returned from the sourcemap
                        stackFrame.source.path = undefined;
                        stackFrame.source.name = path.basename(mapped.source);
                        stackFrame.source.sourceReference = _this._sourceHandles.create({ contents: inlinedSource, mappedPath: mapped.source });
                        stackFrame.line = mapped.line;
                        stackFrame.column = mapped.column;
                    }
                    else if (utils.existsSync(stackFrame.source.path)) {
                        // Script could not be mapped, but does exist on disk. Keep it and clear the sourceReference.
                        stackFrame.source.sourceReference = 0;
                    }
                    else {
                        // Script could not be mapped and doesn't exist on disk. Clear the path, use sourceReference.
                        stackFrame.source.path = undefined;
                    }
                }
            });
        }
        else {
            response.stackFrames.forEach(function (stackFrame) {
                // PathTransformer needs to leave the frame in an unfinished state because it doesn't know whether sourcemaps are enabled
                if (stackFrame.source.path && stackFrame.source.sourceReference) {
                    stackFrame.source.path = undefined;
                }
            });
        }
    };
    BaseSourceMapTransformer.prototype.scriptParsed = function (pathToGenerated, sourceMapURL) {
        var _this = this;
        if (this._sourceMaps) {
            this._allRuntimeScriptPaths.add(pathToGenerated);
            if (!sourceMapURL)
                return Promise.resolve();
            // Load the sourcemap for this new script and log its sources
            return this._sourceMaps.processNewSourceMap(pathToGenerated, sourceMapURL).then(function () {
                var sources = _this._sourceMaps.allMappedSources(pathToGenerated);
                if (sources) {
                    logger.log("SourceMaps.scriptParsed: " + pathToGenerated + " was just loaded and has mapped sources: " + JSON.stringify(sources));
                }
                return sources;
            });
        }
        else {
            return Promise.resolve();
        }
    };
    BaseSourceMapTransformer.prototype.breakpointResolved = function (bp, scriptPath) {
        if (this._sourceMaps) {
            var mapped = this._sourceMaps.mapToAuthored(scriptPath, bp.line, bp.column);
            if (mapped) {
                // No need to send back the path, the bp can only move within its script
                bp.line = mapped.line;
                bp.column = mapped.column;
            }
        }
    };
    BaseSourceMapTransformer.prototype.mapToGenerated = function (authoredPath, line, column) {
        var _this = this;
        return this._preLoad.then(function () { return _this._sourceMaps.mapToGenerated(authoredPath, line, column); });
    };
    BaseSourceMapTransformer.prototype.mapToAuthored = function (pathToGenerated, line, column) {
        var _this = this;
        return this._preLoad.then(function () { return _this._sourceMaps.mapToAuthored(pathToGenerated, line, column); });
    };
    BaseSourceMapTransformer.prototype.getGeneratedPathFromAuthoredPath = function (authoredPath) {
        var _this = this;
        if (!this._sourceMaps)
            return Promise.resolve(authoredPath);
        return this._preLoad.then(function () {
            // Find the generated path, or check whether this script is actually a runtime path - if so, return that
            return _this._sourceMaps.getGeneratedPathFromAuthoredPath(authoredPath) ||
                (_this._allRuntimeScriptPaths.has(authoredPath) ? authoredPath : null);
        });
    };
    return BaseSourceMapTransformer;
}());
exports.BaseSourceMapTransformer = BaseSourceMapTransformer;

//# sourceMappingURL=baseSourceMapTransformer.js.map
