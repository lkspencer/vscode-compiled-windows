/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var basePathTransformer_1 = require('./basePathTransformer');
var utils = require('../utils');
var logger = require('../logger');
var ChromeUtils = require('../chrome/chromeUtils');
/**
 * Converts a local path from Code to a path on the target.
 */
var UrlPathTransformer = (function (_super) {
    __extends(UrlPathTransformer, _super);
    function UrlPathTransformer() {
        _super.apply(this, arguments);
        this._clientPathToTargetUrl = new Map();
        this._targetUrlToClientPath = new Map();
    }
    UrlPathTransformer.prototype.launch = function (args) {
        this._webRoot = args.webRoot;
        return _super.prototype.launch.call(this, args);
    };
    UrlPathTransformer.prototype.attach = function (args) {
        this._webRoot = args.webRoot;
        return _super.prototype.attach.call(this, args);
    };
    UrlPathTransformer.prototype.setBreakpoints = function (args) {
        if (!args.source.path) {
            // sourceReference script, nothing to do
            return true;
        }
        if (utils.isURL(args.source.path)) {
            // already a url, use as-is
            logger.log("Paths.setBP: " + args.source.path + " is already a URL");
            return true;
        }
        var path = utils.canonicalizeUrl(args.source.path);
        var url = this.getTargetPathFromClientPath(path);
        if (url) {
            args.source.path = url;
            logger.log("Paths.setBP: Resolved " + path + " to " + args.source.path);
            return true;
        }
        else {
            logger.log("Paths.setBP: No target url cached yet for client path: " + path + ".");
            args.source.path = path;
            return false;
        }
    };
    UrlPathTransformer.prototype.clearTargetContext = function () {
        this._clientPathToTargetUrl = new Map();
        this._targetUrlToClientPath = new Map();
    };
    UrlPathTransformer.prototype.scriptParsed = function (scriptUrl) {
        var clientPath = ChromeUtils.targetUrlToClientPath(this._webRoot, scriptUrl);
        if (!clientPath) {
            // It's expected that eval scripts (debugadapter:) won't be resolved
            if (!scriptUrl.startsWith('debugadapter://')) {
                logger.log("Paths.scriptParsed: could not resolve " + scriptUrl + " to a file under webRoot: " + this._webRoot + ". It may be external or served directly from the server's memory (and that's OK).");
            }
        }
        else {
            logger.log("Paths.scriptParsed: resolved " + scriptUrl + " to " + clientPath + ". webRoot: " + this._webRoot);
            this._clientPathToTargetUrl.set(clientPath, scriptUrl);
            this._targetUrlToClientPath.set(scriptUrl, clientPath);
            scriptUrl = clientPath;
        }
        return scriptUrl;
    };
    UrlPathTransformer.prototype.stackTraceResponse = function (response) {
        var _this = this;
        response.stackFrames.forEach(function (frame) {
            if (frame.source.path) {
                // Try to resolve the url to a path in the workspace. If it's not in the workspace,
                // just use the script.url as-is. It will be resolved or cleared by the SourceMapTransformer.
                var clientPath = _this.getClientPathFromTargetPath(frame.source.path) ||
                    ChromeUtils.targetUrlToClientPath(_this._webRoot, frame.source.path);
                // Incoming stackFrames have sourceReference and path set. If the path was resolved to a file in the workspace,
                // clear the sourceReference since it's not needed.
                if (clientPath) {
                    frame.source.path = clientPath;
                    frame.source.sourceReference = 0;
                }
            }
        });
    };
    UrlPathTransformer.prototype.getTargetPathFromClientPath = function (clientPath) {
        return this._clientPathToTargetUrl.get(utils.canonicalizeUrl(clientPath));
    };
    UrlPathTransformer.prototype.getClientPathFromTargetPath = function (targetPath) {
        return this._targetUrlToClientPath.get(utils.canonicalizeUrl(targetPath));
    };
    return UrlPathTransformer;
}(basePathTransformer_1.BasePathTransformer));
exports.UrlPathTransformer = UrlPathTransformer;

//# sourceMappingURL=urlPathTransformer.js.map
