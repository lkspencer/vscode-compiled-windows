"use strict";
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_debugadapter_1 = require("vscode-debugadapter");
class TelemetryReporter {
    reportEvent(name, data) {
        if (this._sendEvent) {
            const event = new vscode_debugadapter_1.OutputEvent(name, 'telemetry', data);
            this._sendEvent(event);
        }
    }
    setupEventHandler(_sendEvent) {
        this._sendEvent = _sendEvent;
    }
}
exports.TelemetryReporter = TelemetryReporter;
class NullTelemetryReporter {
    reportEvent(name, data) {
        // no-op
    }
    setupEventHandler(_sendEvent) {
        // no-op
    }
}
exports.NullTelemetryReporter = NullTelemetryReporter;
exports.DefaultTelemetryIntervalInMilliseconds = 10000;
class BatchTelemetryReporter {
    constructor(_telemetryReporter, _cadenceInMilliseconds = exports.DefaultTelemetryIntervalInMilliseconds) {
        this._telemetryReporter = _telemetryReporter;
        this._cadenceInMilliseconds = _cadenceInMilliseconds;
        this.reset();
        this.setup();
    }
    reportEvent(name, data) {
        if (!this._eventBuckets[name]) {
            this._eventBuckets[name] = [];
        }
        this._eventBuckets[name].push(data);
    }
    finalize() {
        this.send();
        clearInterval(this._timer);
    }
    setup() {
        this._timer = setInterval(() => this.send(), this._cadenceInMilliseconds);
    }
    reset() {
        this._eventBuckets = {};
    }
    send() {
        for (const eventName in this._eventBuckets) {
            const bucket = this._eventBuckets[eventName];
            let properties = BatchTelemetryReporter.transfromBucketData(bucket);
            this._telemetryReporter.reportEvent(eventName, properties);
        }
        this.reset();
    }
    /**
     * Transfrom the bucket of events data from the form:
     * [{
     *  p1: v1,
     *  p2: v2
     * },
     * {
     *  p1: w1,
     *  p2: w2
     *  p3: w3
     * }]
     *
     * to
     * {
     *   p1: [v1,   w1],
     *   p2: [v2,   w2],
     *   p3: [null, w3]
     * }
     *
     *
     * The later form is easier for downstream telemetry analysis.
     */
    static transfromBucketData(bucketForEventType) {
        const allPropertyNamesInTheBucket = BatchTelemetryReporter.collectPropertyNamesFromAllEvents(bucketForEventType);
        let properties = {};
        // Create a holder for all potential property names.
        for (const key of allPropertyNamesInTheBucket) {
            properties[`aggregated.${key}`] = [];
        }
        // Run through all the events in the bucket, collect the values for each property name.
        for (const event of bucketForEventType) {
            for (const propertyName of allPropertyNamesInTheBucket) {
                properties[`aggregated.${propertyName}`].push(event[propertyName] === undefined ? null : event[propertyName]);
            }
        }
        // Serialize each array as the final aggregated property value.
        for (const propertyName of allPropertyNamesInTheBucket) {
            properties[`aggregated.${propertyName}`] = JSON.stringify(properties[`aggregated.${propertyName}`]);
        }
        return properties;
    }
    /**
     * Get the property keys from all the entries of a event bucket:
     *
     * So
     * [{
     *  p1: v1,
     *  p2: v2
     * },
     * {
     *  p1: w1,
     *  p2: w2
     *  p3: w3
     * }]
     *
     * will return ['p1', 'p2', 'p3']
     */
    static collectPropertyNamesFromAllEvents(bucket) {
        let propertyNamesSet = {};
        for (const entry of bucket) {
            for (const key of Object.keys(entry)) {
                propertyNamesSet[key] = true;
            }
        }
        return Object.keys(propertyNamesSet);
    }
}
exports.BatchTelemetryReporter = BatchTelemetryReporter;
exports.telemetry = new TelemetryReporter();

//# sourceMappingURL=telemetry.js.map
