/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var os = require('os');
var vscode_debugadapter_1 = require('vscode-debugadapter');
var utils = require('../utils');
var logger = require('../logger');
var ChromeDebugSession = (function (_super) {
    __extends(ChromeDebugSession, _super);
    function ChromeDebugSession(debuggerLinesAndColumnsStartAt1, isServer, opts) {
        var _this = this;
        _super.call(this);
        this._extensionName = opts.extensionName;
        this._debugAdapter = new opts.adapter(opts);
        this._debugAdapter.registerEventHandler(this.sendEvent.bind(this));
        this._debugAdapter.registerRequestHandler(this.sendRequest.bind(this));
        var logFilePath = opts.logFilePath;
        logger.init(function (msg, level) { return _this.onLog(msg, level); }, logFilePath, isServer);
        logVersionInfo();
        process.addListener('unhandledRejection', function (err) {
            // err is a DebugProtocol.Message or Error
            var errMsg = err.stack ? err.stack : JSON.stringify(err);
            logger.error("******** Error in DebugAdapter - Unhandled promise rejection: " + errMsg);
        });
    }
    /**
     * This needs a bit of explanation -
     * The Session is reinstantiated for each session, but consumers need to configure their instance of
     * ChromeDebugSession. Consumers should call getSession with their config options, then call
     * DebugSession.run with the result. Alternatively they could subclass ChromeDebugSession and pass
     * their options to the super constructor, but I think this is easier to follow.
     */
    ChromeDebugSession.getSession = function (opts) {
        // class expression!
        return (function (_super) {
            __extends(class_1, _super);
            function class_1(debuggerLinesAndColumnsStartAt1, isServer) {
                _super.call(this, debuggerLinesAndColumnsStartAt1, isServer, opts);
            }
            return class_1;
        }(ChromeDebugSession));
    };
    /**
     * Overload sendEvent to log
     */
    ChromeDebugSession.prototype.sendEvent = function (event) {
        if (event.event !== 'output') {
            // Don't create an infinite loop...
            logger.verbose("To client: " + JSON.stringify(event));
        }
        _super.prototype.sendEvent.call(this, event);
    };
    /**
     * Overload sendRequest to log
     */
    ChromeDebugSession.prototype.sendRequest = function (command, args, timeout, cb) {
        logger.verbose("To client: " + JSON.stringify(command) + "(" + JSON.stringify(args) + "), timeout: " + timeout);
        _super.prototype.sendRequest.call(this, command, args, timeout, cb);
    };
    /**
     * Overload sendResponse to log
     */
    ChromeDebugSession.prototype.sendResponse = function (response) {
        logger.verbose("To client: " + JSON.stringify(response));
        _super.prototype.sendResponse.call(this, response);
    };
    ChromeDebugSession.prototype.shutdown = function () {
        this._debugAdapter.shutdown();
        _super.prototype.shutdown.call(this);
    };
    ChromeDebugSession.prototype.onLog = function (msg, level) {
        var outputCategory = level === logger.LogLevel.Error ? 'stderr' : 'stdout';
        if (level === logger.LogLevel.Verbose) {
            // Distinguish verbose messages with this prefix - makes the logs much more readable
            msg = "  \u203A" + msg;
        }
        this.sendEvent(new vscode_debugadapter_1.OutputEvent(msg + '\n', outputCategory));
    };
    /**
     * Takes a response and a promise to the response body. If the promise is successful, assigns the response body and sends the response.
     * If the promise fails, sets the appropriate response parameters and sends the response.
     */
    ChromeDebugSession.prototype.sendResponseAsync = function (request, response, responseP) {
        var _this = this;
        responseP.then(function (body) {
            response.body = body;
            _this.sendResponse(response);
        }, function (e) {
            if (e.format) {
                _this.sendErrorResponse(response, e);
                return;
            }
            var eStr = e ? e.message : 'Unknown error';
            if (eStr === 'Error: unknowncommand') {
                _this.sendErrorResponse(response, 1014, "[" + _this._extensionName + "] Unrecognized request: " + request.command, null, vscode_debugadapter_1.ErrorDestination.Telemetry);
                return;
            }
            if (request.command === 'evaluate') {
                // Errors from evaluate show up in the console or watches pane. Doesn't seem right
                // as it's not really a failed request. So it doesn't need the [extensionName] tag and worth special casing.
                response.message = eStr;
            }
            else {
                // These errors show up in the message bar at the top (or nowhere), sometimes not obvious that they
                // come from the adapter
                response.message = "[" + _this._extensionName + "] " + eStr;
                logger.log('Error: ' + e ? e.stack : eStr);
            }
            response.success = false;
            _this.sendResponse(response);
        });
    };
    /**
     * Overload dispatchRequest to the debug adapters' Promise-based methods instead of DebugSession's callback-based methods
     */
    ChromeDebugSession.prototype.dispatchRequest = function (request) {
        var response = new vscode_debugadapter_1.Response(request);
        try {
            logger.verbose("From client: " + request.command + "(" + JSON.stringify(request.arguments) + ")");
            var responseP = (request.command in this._debugAdapter) ?
                Promise.resolve(this._debugAdapter[request.command](request.arguments, request.seq)) :
                utils.errP('unknowncommand');
            this.sendResponseAsync(request, response, responseP);
        }
        catch (e) {
            this.sendErrorResponse(response, 1104, 'Exception while processing request (exception: {_exception})', { _exception: e.message }, vscode_debugadapter_1.ErrorDestination.Telemetry);
        }
    };
    return ChromeDebugSession;
}(vscode_debugadapter_1.DebugSession));
exports.ChromeDebugSession = ChromeDebugSession;
function logVersionInfo() {
    logger.log("OS: " + os.platform() + " " + os.arch());
    logger.log('Node: ' + process.version);
    logger.log('vscode-chrome-debug-core: ' + require('../../../package.json').version);
}

//# sourceMappingURL=chromeDebugSession.js.map
