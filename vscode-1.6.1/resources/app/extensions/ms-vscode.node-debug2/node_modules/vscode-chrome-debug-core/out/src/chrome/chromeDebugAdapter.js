/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var vscode_debugadapter_1 = require('vscode-debugadapter');
var chromeConnection_1 = require('./chromeConnection');
var ChromeUtils = require('./chromeUtils');
var variables_1 = require('./variables');
var errors = require('../errors');
var utils = require('../utils');
var logger = require('../logger');
var baseDebugAdapter_1 = require('../baseDebugAdapter');
var lineNumberTransformer_1 = require('../transformers/lineNumberTransformer');
var remotePathTransformer_1 = require('../transformers/remotePathTransformer');
var eagerSourceMapTransformer_1 = require('../transformers/eagerSourceMapTransformer');
var path = require('path');
var ChromeDebugAdapter = (function (_super) {
    __extends(ChromeDebugAdapter, _super);
    function ChromeDebugAdapter(_a) {
        var chromeConnection = _a.chromeConnection, lineNumberTransformer = _a.lineNumberTransformer, sourceMapTransformer = _a.sourceMapTransformer, pathTransformer = _a.pathTransformer;
        _super.call(this);
        this._currentStep = Promise.resolve();
        this._nextUnboundBreakpointId = 0;
        this._chromeConnection = new (chromeConnection || chromeConnection_1.ChromeConnection)();
        this._variableHandles = new vscode_debugadapter_1.Handles();
        this._breakpointIdHandles = new utils.ReverseHandles();
        this._sourceHandles = new vscode_debugadapter_1.Handles();
        this._pendingBreakpointsByUrl = new Map();
        this._overlayHelper = new utils.DebounceHelper(/*timeoutMs=*/ 200);
        this._lineNumberTransformer = new (lineNumberTransformer || lineNumberTransformer_1.LineNumberTransformer)(/*targetLinesStartAt1=*/ false);
        this._sourceMapTransformer = new (sourceMapTransformer || eagerSourceMapTransformer_1.EagerSourceMapTransformer)(this._sourceHandles);
        this._pathTransformer = new (pathTransformer || remotePathTransformer_1.RemotePathTransformer)();
        this.clearTargetContext();
    }
    Object.defineProperty(ChromeDebugAdapter.prototype, "paused", {
        get: function () {
            return !!this._currentStack;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Called on 'clearEverything' or on a navigation/refresh
     */
    ChromeDebugAdapter.prototype.clearTargetContext = function () {
        this._sourceMapTransformer.clearTargetContext();
        this._scriptsById = new Map();
        this._scriptsByUrl = new Map();
        this._committedBreakpointsByUrl = new Map();
        this._setBreakpointsRequestQ = Promise.resolve();
        this._pathTransformer.clearTargetContext();
    };
    ChromeDebugAdapter.prototype.initialize = function (args) {
        if (args.pathFormat !== 'path') {
            return Promise.reject(errors.pathFormat());
        }
        this._lineNumberTransformer.initialize(args);
        // This debug adapter supports two exception breakpoint filters
        return {
            exceptionBreakpointFilters: [
                {
                    label: 'All Exceptions',
                    filter: 'all',
                    default: false
                },
                {
                    label: 'Uncaught Exceptions',
                    filter: 'uncaught',
                    default: true
                }
            ],
            supportsConfigurationDoneRequest: true,
            supportsSetVariable: true,
            supportsConditionalBreakpoints: true
        };
    };
    ChromeDebugAdapter.prototype.configurationDone = function () {
        return Promise.resolve();
    };
    ChromeDebugAdapter.prototype.launch = function (args) {
        this._sourceMapTransformer.launch(args);
        this._pathTransformer.launch(args);
        this.setupLogging(args);
        return Promise.resolve();
    };
    ChromeDebugAdapter.prototype.attach = function (args) {
        this._attachMode = true;
        this._sourceMapTransformer.attach(args);
        this._pathTransformer.attach(args);
        if (args.port == null) {
            return utils.errP('The "port" field is required in the attach config.');
        }
        this.setupLogging(args);
        return this.doAttach(args.port, args.url, args.address);
    };
    ChromeDebugAdapter.prototype.setupLogging = function (args) {
        var minLogLevel = args.verboseDiagnosticLogging ?
            logger.LogLevel.Verbose :
            args.diagnosticLogging ?
                logger.LogLevel.Log :
                logger.LogLevel.Error;
        logger.setMinLogLevel(minLogLevel);
    };
    /**
     * From DebugSession
     */
    ChromeDebugAdapter.prototype.shutdown = function () {
        this._inShutdown = true;
    };
    /**
     * Chrome is closing, or error'd somehow, stop the debug session
     */
    ChromeDebugAdapter.prototype.terminateSession = function (reason, restart) {
        logger.log('Terminated: ' + reason);
        if (!this._hasTerminated) {
            this._hasTerminated = true;
            if (this._clientAttached) {
                this.sendEvent(new vscode_debugadapter_1.TerminatedEvent(restart));
            }
            if (this._chromeConnection.isAttached) {
                this._chromeConnection.close();
            }
        }
    };
    ChromeDebugAdapter.prototype.doAttach = function (port, targetUrl, address, timeout) {
        var _this = this;
        // Client is attaching - if not attached to the chrome target, create a connection and attach
        this._clientAttached = true;
        if (!this._chromeConnection.isAttached) {
            this._chromeConnection.on('Debugger.paused', function (params) { return _this.onDebuggerPaused(params); });
            this._chromeConnection.on('Debugger.resumed', function () { return _this.onDebuggerResumed(); });
            this._chromeConnection.on('Debugger.scriptParsed', function (params) { return _this.onScriptParsed(params); });
            this._chromeConnection.on('Debugger.globalObjectCleared', function () { return _this.onGlobalObjectCleared(); });
            this._chromeConnection.on('Debugger.breakpointResolved', function (params) { return _this.onBreakpointResolved(params); });
            this._chromeConnection.on('Console.messageAdded', function (params) { return _this.onConsoleMessage(params); });
            this._chromeConnection.on('Inspector.detached', function () { return _this.terminateSession('Debug connection detached'); });
            this._chromeConnection.on('close', function () { return _this.terminateSession('Debug connection closed'); });
            this._chromeConnection.on('error', function (e) { return _this.terminateSession('Debug connection error: ' + e); });
            return this._chromeConnection.attach(address, port, targetUrl)
                .then(function () { return _this.sendInitializedEvent(); });
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * This event tells the client to begin sending setBP requests, etc. Some consumers need to override this
     * to send it at a later time of their choosing.
     */
    ChromeDebugAdapter.prototype.sendInitializedEvent = function () {
        this.sendEvent(new vscode_debugadapter_1.InitializedEvent());
    };
    /**
     * e.g. the target navigated
     */
    ChromeDebugAdapter.prototype.onGlobalObjectCleared = function () {
        this.clearTargetContext();
    };
    ChromeDebugAdapter.prototype.onDebuggerPaused = function (notification) {
        var _this = this;
        this._overlayHelper.doAndCancel(function () { return _this._chromeConnection.page_setOverlayMessage(ChromeDebugAdapter.PAGE_PAUSE_MESSAGE); });
        this._currentStack = notification.callFrames;
        // We can tell when we've broken on an exception. Otherwise if hitBreakpoints is set, assume we hit a
        // breakpoint. If not set, assume it was a step. We can't tell the difference between step and 'break on anything'.
        var reason;
        var exceptionText;
        if (notification.reason === 'exception') {
            reason = 'exception';
            if (notification.data && this._currentStack.length) {
                // Insert a scope to wrap the exception object. exceptionText is unused by Code at the moment.
                var scopeObject = void 0;
                if (notification.data.objectId) {
                    // If the remote object is an object (probably an Error), treat the object like a scope.
                    exceptionText = notification.data.description;
                    scopeObject = notification.data;
                }
                else {
                    // If it's a value, use a special flag and save the value for later.
                    exceptionText = notification.data.value;
                    scopeObject = { objectId: ChromeDebugAdapter.EXCEPTION_VALUE_ID };
                    this._exceptionValueObject = notification.data;
                }
                this._currentStack[0].scopeChain.unshift({ type: 'Exception', object: scopeObject });
            }
        }
        else if (notification.hitBreakpoints && notification.hitBreakpoints.length) {
            reason = 'breakpoint';
        }
        else {
            reason = this._expectingStopReason || 'debugger';
        }
        this._expectingStopReason = undefined;
        // Enforce that the stopped event is not fired until we've send the response to the step that induced it.
        // Also with a timeout just to ensure things keep moving
        var sendStoppedEvent = function () {
            return _this.sendEvent(new vscode_debugadapter_1.StoppedEvent(_this.stopReasonText(reason), /*threadId=*/ ChromeDebugAdapter.THREAD_ID, exceptionText));
        };
        utils.promiseTimeout(this._currentStep, /*timeoutMs=*/ 300)
            .then(sendStoppedEvent, sendStoppedEvent);
    };
    ChromeDebugAdapter.prototype.stopReasonText = function (reason) {
        var comment = ['https://github.com/Microsoft/vscode/issues/4568'];
        switch (reason) {
            case 'entry':
                return utils.localize({ key: 'reason.entry', comment: comment }, "entry");
            case 'exception':
                return utils.localize({ key: 'reason.exception', comment: comment }, "exception");
            case 'breakpoint':
                return utils.localize({ key: 'reason.breakpoint', comment: comment }, "breakpoint");
            case 'debugger':
                return utils.localize({ key: 'reason.debugger_statement', comment: comment }, "debugger statement");
            case 'frame_entry':
                return utils.localize({ key: 'reason.restart', comment: comment }, "frame entry");
            case 'step':
                return utils.localize({ key: 'reason.step', comment: comment }, "step");
            case 'user_request':
                return utils.localize({ key: 'reason.user_request', comment: comment }, "user request");
            default:
                return reason;
        }
    };
    ChromeDebugAdapter.prototype.onDebuggerResumed = function () {
        var _this = this;
        this._overlayHelper.wait(function () { return _this._chromeConnection.page_clearOverlayMessage(); });
        this._currentStack = null;
        if (!this._expectingResumedEvent) {
            var resumedEvent = new vscode_debugadapter_1.ContinuedEvent(ChromeDebugAdapter.THREAD_ID);
            this.sendEvent(resumedEvent);
        }
        else {
            this._expectingResumedEvent = false;
        }
    };
    ChromeDebugAdapter.prototype.onScriptParsed = function (script) {
        var _this = this;
        // Totally ignore extension scripts, internal Chrome scripts, and so on
        if (this.shouldIgnoreScript(script)) {
            return;
        }
        if (!script.url) {
            script.url = ChromeDebugAdapter.PLACEHOLDER_URL_PROTOCOL + script.scriptId;
        }
        this._scriptsById.set(script.scriptId, script);
        this._scriptsByUrl.set(script.url, script);
        var mappedUrl = this._pathTransformer.scriptParsed(script.url);
        this._sourceMapTransformer.scriptParsed(mappedUrl, script.sourceMapURL).then(function (sources) {
            if (sources) {
                sources.forEach(function (source) {
                    if (_this._pendingBreakpointsByUrl.has(source)) {
                        _this.resolvePendingBreakpoints(_this._pendingBreakpointsByUrl.get(source));
                    }
                });
            }
        });
    };
    ChromeDebugAdapter.prototype.resolvePendingBreakpoints = function (pendingBP) {
        var _this = this;
        this.setBreakpoints(pendingBP.args, 0).then(function (response) {
            response.breakpoints.forEach(function (bp, i) {
                bp.id = pendingBP.ids[i];
                _this.sendEvent(new vscode_debugadapter_1.BreakpointEvent('new', bp));
            });
        });
    };
    ChromeDebugAdapter.prototype.onBreakpointResolved = function (params) {
        var script = this._scriptsById.get(params.location.scriptId);
        if (!script) {
            // Breakpoint resolved for a script we don't know about
            return;
        }
        var committedBps = this._committedBreakpointsByUrl.get(script.url) || [];
        committedBps.push(params.breakpointId);
        this._committedBreakpointsByUrl.set(script.url, committedBps);
        var bp = {
            id: this._breakpointIdHandles.lookup(params.breakpointId),
            verified: true,
            line: params.location.lineNumber,
            column: params.location.columnNumber
        };
        var scriptPath = this._pathTransformer.breakpointResolved(bp, script.url);
        this._sourceMapTransformer.breakpointResolved(bp, scriptPath);
        this._lineNumberTransformer.breakpointResolved(bp);
        this.sendEvent(new vscode_debugadapter_1.BreakpointEvent('new', bp));
    };
    ChromeDebugAdapter.prototype.onConsoleMessage = function (params) {
        // Consumers can implement this if they want to
    };
    ChromeDebugAdapter.prototype.disconnect = function () {
        return this.terminateSession('Got disconnect request');
    };
    ChromeDebugAdapter.prototype.setBreakpoints = function (args, requestSeq) {
        var _this = this;
        return this.validateBreakpointsPath(args)
            .then(function () {
            _this._lineNumberTransformer.setBreakpoints(args);
            _this._sourceMapTransformer.setBreakpoints(args, requestSeq);
            _this._pathTransformer.setBreakpoints(args);
            var targetScriptUrl;
            if (args.source.path) {
                targetScriptUrl = args.source.path;
            }
            else if (args.source.sourceReference) {
                var handle = _this._sourceHandles.get(args.source.sourceReference);
                var targetScript = _this._scriptsById.get(handle.scriptId);
                if (targetScript) {
                    targetScriptUrl = targetScript.url;
                }
            }
            if (targetScriptUrl) {
                // DebugProtocol sends all current breakpoints for the script. Clear all scripts for the breakpoint then add all of them
                var setBreakpointsPFailOnError = _this._setBreakpointsRequestQ
                    .then(function () { return _this.clearAllBreakpoints(targetScriptUrl); })
                    .then(function () { return _this.addBreakpoints(targetScriptUrl, args.breakpoints); })
                    .then(function (responses) { return ({ breakpoints: _this.chromeBreakpointResponsesToODPBreakpoints(targetScriptUrl, responses, args.breakpoints) }); });
                var setBreakpointsPTimeout = utils.promiseTimeout(setBreakpointsPFailOnError, ChromeDebugAdapter.SET_BREAKPOINTS_TIMEOUT, 'Set breakpoints request timed out');
                // Do just one setBreakpointsRequest at a time to avoid interleaving breakpoint removed/breakpoint added requests to Chrome.
                // Swallow errors in the promise queue chain so it doesn't get blocked, but return the failing promise for error handling.
                _this._setBreakpointsRequestQ = setBreakpointsPTimeout.catch(function () { return undefined; });
                return setBreakpointsPTimeout.then(function (body) {
                    _this._sourceMapTransformer.setBreakpointsResponse(body, requestSeq);
                    _this._lineNumberTransformer.setBreakpointsResponse(body);
                    return body;
                });
            }
            else {
                return Promise.resolve(_this.unverifiedBpResponse(args, utils.localize('bp.fail.noscript', "Can't find script for breakpoint request")));
            }
        }, function (e) { return _this.unverifiedBpResponse(args, e.message); });
    };
    ChromeDebugAdapter.prototype.validateBreakpointsPath = function (args) {
        var _this = this;
        if (!args.source.path)
            return Promise.resolve();
        return this._sourceMapTransformer.getGeneratedPathFromAuthoredPath(args.source.path).then(function (mappedPath) {
            if (!mappedPath) {
                return utils.errP(utils.localize('sourcemapping.fail.message', "Breakpoint ignored because generated code not found (source map problem?)."));
            }
            var targetPath = _this._pathTransformer.getTargetPathFromClientPath(mappedPath);
            if (!targetPath) {
                return Promise.reject(undefined);
            }
            return undefined;
        });
    };
    ChromeDebugAdapter.prototype.unverifiedBpResponse = function (args, message) {
        var _this = this;
        var breakpoints = args.breakpoints.map(function (bp) {
            return {
                verified: false,
                line: bp.line,
                column: bp.column,
                message: message,
                id: _this._breakpointIdHandles.create(_this._nextUnboundBreakpointId++ + '')
            };
        });
        if (args.source.path) {
            var ids = breakpoints.map(function (bp) { return bp.id; });
            this._pendingBreakpointsByUrl.set(args.source.path, { args: args, ids: ids });
        }
        return { breakpoints: breakpoints };
    };
    ChromeDebugAdapter.prototype.clearAllBreakpoints = function (url) {
        var _this = this;
        if (!this._committedBreakpointsByUrl.has(url)) {
            return Promise.resolve();
        }
        // Remove breakpoints one at a time. Seems like it would be ok to send the removes all at once,
        // but there is a chrome bug where when removing 5+ or so breakpoints at once, it gets into a weird
        // state where later adds on the same line will fail with 'breakpoint already exists' even though it
        // does not break there.
        return this._committedBreakpointsByUrl.get(url).reduce(function (p, bpId) {
            return p.then(function () { return _this._chromeConnection.debugger_removeBreakpoint(bpId); }).then(function () { });
        }, Promise.resolve()).then(function () {
            _this._committedBreakpointsByUrl.set(url, null);
        });
    };
    /**
     * Makes the actual call to either Debugger.setBreakpoint or Debugger.setBreakpointByUrl, and returns the response.
     * Responses from setBreakpointByUrl are transformed to look like the response from setBreakpoint, so they can be
     * handled the same.
     */
    ChromeDebugAdapter.prototype.addBreakpoints = function (url, breakpoints) {
        var _this = this;
        var responsePs;
        if (url.startsWith(ChromeDebugAdapter.PLACEHOLDER_URL_PROTOCOL)) {
            // eval script with no real url - use debugger_setBreakpoint
            var scriptId_1 = utils.lstrip(url, ChromeDebugAdapter.PLACEHOLDER_URL_PROTOCOL);
            responsePs = breakpoints.map(function (_a, i) {
                var line = _a.line, _b = _a.column, column = _b === void 0 ? 0 : _b, condition = _a.condition;
                return _this._chromeConnection.debugger_setBreakpoint({ scriptId: scriptId_1, lineNumber: line, columnNumber: column }, condition);
            });
        }
        else {
            // script that has a url - use debugger_setBreakpointByUrl so that Chrome will rebind the breakpoint immediately
            // after refreshing the page. This is the only way to allow hitting breakpoints in code that runs immediately when
            // the page loads.
            var script_1 = this._scriptsByUrl.get(url);
            var urlRegex_1 = utils.pathToRegex(url);
            responsePs = breakpoints.map(function (_a, i) {
                var line = _a.line, _b = _a.column, column = _b === void 0 ? 0 : _b, condition = _a.condition;
                return _this._chromeConnection.debugger_setBreakpointByUrlRegex(urlRegex_1, line, column, condition).then(function (response) {
                    // Now convert the response to a SetBreakpointResponse so both response types can be handled the same
                    var locations = response.result.locations;
                    return {
                        id: response.id,
                        error: response.error,
                        result: {
                            breakpointId: response.result.breakpointId,
                            actualLocation: locations[0] && {
                                lineNumber: locations[0].lineNumber,
                                columnNumber: locations[0].columnNumber,
                                scriptId: script_1.scriptId
                            }
                        }
                    };
                });
            });
        }
        // Join all setBreakpoint requests to a single promise
        return Promise.all(responsePs);
    };
    ChromeDebugAdapter.prototype.chromeBreakpointResponsesToODPBreakpoints = function (url, responses, requestBps) {
        var _this = this;
        // Don't cache errored responses
        var committedBpIds = responses
            .filter(function (response) { return !response.error; })
            .map(function (response) { return response.result.breakpointId; });
        // Cache successfully set breakpoint ids from chrome in committedBreakpoints set
        this._committedBreakpointsByUrl.set(url, committedBpIds);
        // Map committed breakpoints to DebugProtocol response breakpoints
        return responses
            .map(function (response, i) {
            var id = response.result ? _this._breakpointIdHandles.create(response.result.breakpointId) : undefined;
            // The output list needs to be the same length as the input list, so map errors to
            // unverified breakpoints.
            if (response.error || !response.result.actualLocation) {
                return {
                    id: id,
                    verified: false,
                    line: requestBps[i].line,
                    column: requestBps[i].column || 0,
                };
            }
            return {
                id: id,
                verified: true,
                line: response.result.actualLocation.lineNumber,
                column: response.result.actualLocation.columnNumber
            };
        });
    };
    ChromeDebugAdapter.prototype.setExceptionBreakpoints = function (args) {
        var state;
        if (args.filters.indexOf('all') >= 0) {
            state = 'all';
        }
        else if (args.filters.indexOf('uncaught') >= 0) {
            state = 'uncaught';
        }
        else {
            state = 'none';
        }
        return this._chromeConnection.debugger_setPauseOnExceptions(state)
            .then(function () { });
    };
    ChromeDebugAdapter.prototype.continue = function () {
        this._expectingResumedEvent = true;
        return this._currentStep = this._chromeConnection.debugger_resume()
            .then(function () { });
    };
    ChromeDebugAdapter.prototype.next = function () {
        this._expectingStopReason = 'step';
        this._expectingResumedEvent = true;
        return this._currentStep = this._chromeConnection.debugger_stepOver()
            .then(function () { });
    };
    ChromeDebugAdapter.prototype.stepIn = function () {
        this._expectingStopReason = 'step';
        this._expectingResumedEvent = true;
        return this._currentStep = this._chromeConnection.debugger_stepIn()
            .then(function () { });
    };
    ChromeDebugAdapter.prototype.stepOut = function () {
        this._expectingStopReason = 'step';
        this._expectingResumedEvent = true;
        return this._currentStep = this._chromeConnection.debugger_stepOut()
            .then(function () { });
    };
    ChromeDebugAdapter.prototype.pause = function () {
        this._expectingStopReason = 'user_request';
        return this._currentStep = this._chromeConnection.debugger_pause()
            .then(function () { });
    };
    ChromeDebugAdapter.prototype.stackTrace = function (args) {
        var _this = this;
        // Only process at the requested number of frames, if 'levels' is specified
        var stack = this._currentStack;
        if (args.levels) {
            stack = this._currentStack.filter(function (_, i) { return i < args.levels; });
        }
        var stackFrames = stack
            .map(function (_a, i) {
            var location = _a.location, functionName = _a.functionName;
            var line = location.lineNumber;
            var column = location.columnNumber;
            var script = _this._scriptsById.get(location.scriptId);
            try {
                // When the script has a url and isn't one we're ignoring, send the name and path fields. PathTransformer will
                // attempt to resolve it to a script in the workspace. Otherwise, send the name and sourceReference fields.
                var source = script && !_this.shouldIgnoreScript(script) ?
                    {
                        name: path.basename(script.url),
                        path: script.url,
                        sourceReference: _this._sourceHandles.create({ scriptId: script.scriptId })
                    } :
                    {
                        name: script && path.basename(script.url),
                        path: ChromeDebugAdapter.PLACEHOLDER_URL_PROTOCOL + location.scriptId,
                        sourceReference: _this._sourceHandles.create({ scriptId: location.scriptId })
                    };
                // If the frame doesn't have a function name, it's either an anonymous function
                // or eval script. If its source has a name, it's probably an anonymous function.
                var frameName = functionName || (script.url ? '(anonymous function)' : '(eval code)');
                return {
                    id: i,
                    name: frameName,
                    source: source,
                    line: line,
                    column: column
                };
            }
            catch (e) {
                // Some targets such as the iOS simulator behave badly and return nonsense callFrames.
                // In these cases, return a dummy stack frame
                return {
                    id: i,
                    name: 'Unknown',
                    source: { name: 'eval:Unknown', path: ChromeDebugAdapter.PLACEHOLDER_URL_PROTOCOL + 'Unknown' },
                    line: line,
                    column: column
                };
            }
        });
        var stackTraceResponse = { stackFrames: stackFrames };
        this._pathTransformer.stackTraceResponse(stackTraceResponse);
        this._sourceMapTransformer.stackTraceResponse(stackTraceResponse);
        this._lineNumberTransformer.stackTraceResponse(stackTraceResponse);
        return stackTraceResponse;
    };
    ChromeDebugAdapter.prototype.scopes = function (args) {
        var _this = this;
        var currentFrame = this._currentStack[args.frameId];
        var scopes = currentFrame.scopeChain.map(function (scope, i) {
            // The first scope should include 'this'. Keep the RemoteObject reference for use by the variables request
            var thisObj = i === 0 && currentFrame.this;
            var returnValue = i === 0 && currentFrame.returnValue;
            var variablesReference = _this._variableHandles.create(new variables_1.ScopeContainer(currentFrame.callFrameId, i, scope.object.objectId, thisObj, returnValue));
            return {
                name: scope.type.substr(0, 1).toUpperCase() + scope.type.substr(1),
                variablesReference: variablesReference,
                expensive: scope.type === 'global'
            };
        });
        return { scopes: scopes };
    };
    ChromeDebugAdapter.prototype.variables = function (args) {
        var handle = this._variableHandles.get(args.variablesReference);
        if (!handle) {
            return Promise.resolve(undefined);
        }
        // TODO create Container for this special exception scope
        // If this is the special marker for an exception value, create a fake property descriptor so the usual route can be used
        if (handle.objectId === ChromeDebugAdapter.EXCEPTION_VALUE_ID) {
            var excValuePropDescriptor = { name: 'exception', value: this._exceptionValueObject };
            return this.propertyDescriptorToVariable(excValuePropDescriptor)
                .then(function (variable) { return ({ variables: [variable] }); });
        }
        return handle.expand(this, args.filter, args.start, args.count).then(function (variables) {
            return { variables: variables };
        });
    };
    ChromeDebugAdapter.prototype.propertyDescriptorToVariable = function (propDesc, owningObjectId) {
        var _this = this;
        if (propDesc.get) {
            var grabGetterValue = 'function remoteFunction(propName) { return this[propName]; }';
            return this._chromeConnection.runtime_callFunctionOn(owningObjectId, grabGetterValue, [{ value: propDesc.name }]).then(function (response) {
                if (response.error) {
                    logger.error('Error evaluating getter - ' + response.error.toString());
                    return { name: propDesc.name, value: response.error.toString(), variablesReference: 0 };
                }
                else if (response.result.exceptionDetails) {
                    // Not an error, getter could be `get foo() { throw new Error('bar'); }`
                    var exceptionDetails = response.result.exceptionDetails;
                    logger.log('Exception thrown evaluating getter - ' + JSON.stringify(exceptionDetails.exception));
                    return { name: propDesc.name, value: response.result.exceptionDetails.exception.description, variablesReference: 0 };
                }
                else {
                    return _this.remoteObjectToVariable(propDesc.name, response.result.result);
                }
            });
        }
        else if (propDesc.set) {
            // setter without a getter, unlikely
            return Promise.resolve({ name: propDesc.name, value: 'setter', variablesReference: 0 });
        }
        else {
            // Non getter/setter
            return this.internalPropertyDescriptorToVariable(propDesc);
        }
    };
    ChromeDebugAdapter.prototype.getVariablesForObjectId = function (objectId, filter, start, count) {
        var _this = this;
        if (typeof start === 'number' && typeof count === 'number') {
            return this.getFilteredVariablesForObject(objectId, filter, start, count);
        }
        return Promise.all([
            // Need to make two requests to get all properties
            this._chromeConnection.runtime_getProperties(objectId, /*ownProperties=*/ false, /*accessorPropertiesOnly=*/ true, /*generatePreview=*/ true),
            this._chromeConnection.runtime_getProperties(objectId, /*ownProperties=*/ true, /*accessorPropertiesOnly=*/ false, /*generatePreview=*/ true)
        ]).then(function (getPropsResponses) {
            // Sometimes duplicates will be returned - merge all descriptors by name
            var propsByName = new Map();
            var internalPropsByName = new Map();
            getPropsResponses.forEach(function (response) {
                if (!response.error) {
                    response.result.result.forEach(function (propDesc) {
                        return propsByName.set(propDesc.name, propDesc);
                    });
                    if (response.result.internalProperties) {
                        response.result.internalProperties.forEach(function (internalProp) {
                            internalPropsByName.set(internalProp.name, internalProp);
                        });
                    }
                }
            });
            // Convert Chrome prop descriptors to DebugProtocol vars
            var variables = [];
            propsByName.forEach(function (propDesc) { return variables.push(_this.propertyDescriptorToVariable(propDesc, objectId)); });
            internalPropsByName.forEach(function (internalProp) { return variables.push(Promise.resolve(_this.internalPropertyDescriptorToVariable(internalProp))); });
            return Promise.all(variables);
        }).then(function (variables) {
            // Sort all variables properly
            return variables.sort(function (var1, var2) { return ChromeUtils.compareVariableNames(var1.name, var2.name); });
        });
    };
    ChromeDebugAdapter.prototype.internalPropertyDescriptorToVariable = function (propDesc) {
        return this.remoteObjectToVariable(propDesc.name, propDesc.value);
    };
    ChromeDebugAdapter.prototype.getFilteredVariablesForObject = function (objectId, filter, start, count) {
        // No ES6, in case we talk to an old runtime
        var getIndexedVariablesFn = "\n            function getIndexedVariables(start, count) {\n                var result = [];\n                for (var i = start; i < (start + count); i++) result[i] = this[i];\n                return result;\n            }";
        // TODO order??
        var getNamedVariablesFn = "\n            function getNamedVariablesFn(start, count) {\n                var result = [];\n                var ownProps = Object.getOwnPropertyNames(this);\n                for (var i = start; i < (start + count); i++) result[i] = ownProps[i];\n                return result;\n            }";
        var getVarsFn = filter === 'indexed' ? getIndexedVariablesFn : getNamedVariablesFn;
        return this.getFilteredVariablesForObjectId(objectId, getVarsFn, filter, start, count);
    };
    ChromeDebugAdapter.prototype.getFilteredVariablesForObjectId = function (objectId, getVarsFn, filter, start, count) {
        var _this = this;
        return this._chromeConnection.runtime_callFunctionOn(objectId, getVarsFn, [{ value: start }, { value: count }], /*silent=*/ true).then(function (evalResponse) {
            if (evalResponse.error) {
                return Promise.reject(errors.errorFromEvaluate(evalResponse.error.message));
            }
            else if (evalResponse.result.exceptionDetails) {
                var errMsg = ChromeUtils.errorMessageFromExceptionDetails(evalResponse.result.exceptionDetails);
                return Promise.reject(errors.errorFromEvaluate(errMsg));
            }
            else {
                // The eval was successful and returned a reference to the array object. Get the props, then filter
                // out everything except the index names.
                return _this.getVariablesForObjectId(evalResponse.result.result.objectId, filter)
                    .then(function (variables) { return variables.filter(function (variable) { return variables_1.isIndexedPropName(variable.name); }); });
            }
        });
    };
    ChromeDebugAdapter.prototype.source = function (args) {
        var handle = this._sourceHandles.get(args.sourceReference);
        if (!handle) {
            return Promise.reject(errors.sourceRequestIllegalHandle());
        }
        // Have inlined content?
        if (handle.contents) {
            return Promise.resolve({
                content: handle.contents
            });
        }
        // If not, should have scriptId
        return this._chromeConnection.debugger_getScriptSource(handle.scriptId).then(function (chromeResponse) {
            return {
                content: chromeResponse.result.scriptSource,
                mimeType: 'text/javascript'
            };
        });
    };
    ChromeDebugAdapter.prototype.threads = function () {
        return {
            threads: [
                {
                    id: ChromeDebugAdapter.THREAD_ID,
                    name: 'Thread ' + ChromeDebugAdapter.THREAD_ID
                }
            ]
        };
    };
    ChromeDebugAdapter.prototype.evaluate = function (args) {
        var _this = this;
        var evalPromise;
        if (this.paused) {
            var callFrameId = this._currentStack[args.frameId].callFrameId;
            evalPromise = this._chromeConnection.debugger_evaluateOnCallFrame(callFrameId, args.expression, undefined, undefined, /*silent=*/ true);
        }
        else {
            evalPromise = this._chromeConnection.runtime_evaluate(args.expression, undefined, undefined, undefined, /*silent=*/ true);
        }
        return evalPromise.then(function (evalResponse) {
            if (evalResponse.result.wasThrown) {
                var evalResult = evalResponse.result;
                var errorMessage = 'Error';
                if (evalResult.exceptionDetails) {
                    errorMessage = evalResult.exceptionDetails.text;
                }
                else if (evalResult.result && evalResult.result.description) {
                    errorMessage = evalResult.result.description;
                }
                return utils.errP(errorMessage);
            }
            // Convert to a Variable object then just copy the relevant fields off
            return _this.remoteObjectToVariable('', evalResponse.result.result);
        }).then(function (variable) {
            return {
                result: variable.value,
                variablesReference: variable.variablesReference,
                indexedVariables: variable.indexedVariables,
                namedVariables: variable.namedVariables
            };
        });
    };
    ChromeDebugAdapter.prototype.setVariable = function (args) {
        var handle = this._variableHandles.get(args.variablesReference);
        if (!handle) {
            return Promise.reject(errors.setValueNotSupported());
        }
        return handle.setValue(this, args.name, args.value)
            .then(function (value) { return ({ value: value }); });
    };
    ChromeDebugAdapter.prototype.setVariableValue = function (frameId, scopeIndex, name, value) {
        var _this = this;
        var evalResultObject;
        return this._chromeConnection.debugger_evaluateOnCallFrame(frameId, value, undefined, undefined, /*silent=*/ true).then(function (evalResponse) {
            if (evalResponse.error) {
                return Promise.reject(errors.errorFromEvaluate(evalResponse.error.message));
            }
            else if (evalResponse.result.exceptionDetails) {
                var errMsg = ChromeUtils.errorMessageFromExceptionDetails(evalResponse.result.exceptionDetails);
                return Promise.reject(errors.errorFromEvaluate(errMsg));
            }
            else {
                evalResultObject = evalResponse.result.result;
                var newVal = ChromeUtils.remoteObjectToCallArgument(evalResultObject);
                return _this._chromeConnection.debugger_setVariableValue(frameId, scopeIndex, name, newVal);
            }
        })
            .then(function (setVarResponse) { return ChromeUtils.remoteObjectToValue(evalResultObject).value; });
    };
    ChromeDebugAdapter.prototype.setPropertyValue = function (objectId, propName, value) {
        return this._chromeConnection.runtime_callFunctionOn(objectId, "function() { return this[\"" + propName + "\"] = " + value + " }", undefined, /*silent=*/ true).then(function (response) {
            if (response.error) {
                return Promise.reject(errors.errorFromEvaluate(response.error.message));
            }
            else if (response.result.exceptionDetails) {
                var errMsg = ChromeUtils.errorMessageFromExceptionDetails(response.result.exceptionDetails);
                return Promise.reject(errors.errorFromEvaluate(errMsg));
            }
            else {
                // Temporary, Microsoft/vscode#12019
                return ChromeUtils.remoteObjectToValue(response.result.result).value;
            }
        });
    };
    ChromeDebugAdapter.prototype.remoteObjectToVariable = function (name, object, stringify) {
        if (stringify === void 0) { stringify = true; }
        var value = '';
        if (object) {
            if (object.type === 'object') {
                if (object.subtype === 'internal#location') {
                    // Could format this nicely later, see #110
                    value = 'internal#location';
                }
                else if (object.subtype === 'null') {
                    value = 'null';
                }
                else {
                    return this.createObjectVariable(name, object);
                }
            }
            else if (object.type === 'undefined') {
                value = 'undefined';
            }
            else if (object.type === 'function') {
                return Promise.resolve(this.createFunctionVariable(name, object));
            }
            else {
                // The value is a primitive value, or something that has a description (not object, primitive, or undefined). And force to be string
                if (typeof object.value === 'undefined') {
                    value = object.description;
                }
                else if (object.type === 'number') {
                    // .value is truncated, so use .description, the full string representation
                    // Should be like '3' or 'Infinity'.
                    value = object.description;
                }
                else {
                    value = stringify ? JSON.stringify(object.value) : object.value;
                }
            }
        }
        return Promise.resolve({
            name: name,
            value: value,
            variablesReference: 0
        });
    };
    ChromeDebugAdapter.prototype.createFunctionVariable = function (name, object) {
        var value;
        var firstBraceIdx = object.description.indexOf('{');
        if (firstBraceIdx >= 0) {
            value = object.description.substring(0, firstBraceIdx) + '{ … }';
        }
        else {
            var firstArrowIdx = object.description.indexOf('=>');
            value = firstArrowIdx >= 0 ?
                object.description.substring(0, firstArrowIdx + 2) + ' …' :
                object.description;
        }
        return { name: name, value: value, variablesReference: this._variableHandles.create(new variables_1.PropertyContainer(object.objectId)) };
    };
    ChromeDebugAdapter.prototype.createObjectVariable = function (name, object, stringify) {
        var value = object.description;
        var propCountP;
        if (object.subtype === 'array' || object.subtype === 'typedarray') {
            if (object.preview && !object.preview.overflow) {
                propCountP = Promise.resolve(this.getArrayNumPropsByPreview(object));
            }
            else {
                propCountP = this.getArrayNumPropsByEval(object.objectId);
            }
        }
        else if (object.subtype === 'set' || object.subtype === 'map') {
            if (object.preview && !object.preview.overflow) {
                propCountP = Promise.resolve(this.getCollectionNumPropsByPreview(object));
            }
            else {
                propCountP = this.getCollectionNumPropsByEval(object.objectId);
            }
        }
        else {
            if (object.subtype === 'error') {
                // The Error's description contains the whole stack which is not a nice description.
                // Up to the first newline is just the error name/message.
                var firstNewlineIdx = object.description.indexOf('\n');
                if (firstNewlineIdx >= 0)
                    value = object.description.substr(0, firstNewlineIdx);
            }
            propCountP = Promise.resolve({});
        }
        var variablesReference = this._variableHandles.create(new variables_1.PropertyContainer(object.objectId));
        return propCountP.then(function (_a) {
            var indexedVariables = _a.indexedVariables, namedVariables = _a.namedVariables;
            return ({
                name: name,
                value: value,
                variablesReference: variablesReference,
                indexedVariables: indexedVariables,
                namedVariables: namedVariables
            });
        });
    };
    ChromeDebugAdapter.prototype.getArrayNumPropsByEval = function (objectId) {
        var getNumPropsFn = "function() { return [this.length, Object.keys(this).length - this.length]; }";
        return this.getNumPropsByEval(objectId, getNumPropsFn);
    };
    ChromeDebugAdapter.prototype.getArrayNumPropsByPreview = function (object) {
        var indexedVariables = 0;
        var namedVariables = 0;
        object.preview.properties.forEach(function (prop) { return variables_1.isIndexedPropName(prop.name) ? indexedVariables++ : namedVariables++; });
        return { indexedVariables: indexedVariables, namedVariables: namedVariables };
    };
    ChromeDebugAdapter.prototype.getCollectionNumPropsByEval = function (objectId) {
        var getNumPropsFn = "function() { return [0, Object.keys(this).length + 1]; }"; // +1 for [[Entries]];
        return this.getNumPropsByEval(objectId, getNumPropsFn);
    };
    ChromeDebugAdapter.prototype.getCollectionNumPropsByPreview = function (object) {
        var indexedVariables = 0;
        var namedVariables = object.preview.properties.length + 1; // +1 for [[Entries]];
        return { indexedVariables: indexedVariables, namedVariables: namedVariables };
    };
    ChromeDebugAdapter.prototype.getNumPropsByEval = function (objectId, getNumPropsFn) {
        return this._chromeConnection.runtime_callFunctionOn(objectId, getNumPropsFn, undefined, /*silent=*/ true, /*returnByValue=*/ true).then(function (response) {
            if (response.error) {
                return Promise.reject(errors.errorFromEvaluate(response.error.message));
            }
            else if (response.result.exceptionDetails) {
                var errMsg = ChromeUtils.errorMessageFromExceptionDetails(response.result.exceptionDetails);
                return Promise.reject(errors.errorFromEvaluate(errMsg));
            }
            else {
                var resultProps = response.result.result.value;
                if (resultProps.length !== 2) {
                    return Promise.reject(errors.errorFromEvaluate("Did not get expected props, got " + JSON.stringify(resultProps)));
                }
                return { indexedVariables: resultProps[0], namedVariables: resultProps[1] };
            }
        });
    };
    ChromeDebugAdapter.prototype.shouldIgnoreScript = function (script) {
        return script.isContentScript || script.isInternalScript || script.url.startsWith('extensions::') || script.url.startsWith('chrome-extension://');
    };
    ChromeDebugAdapter.THREAD_ID = 1;
    ChromeDebugAdapter.PAGE_PAUSE_MESSAGE = 'Paused in Visual Studio Code';
    ChromeDebugAdapter.EXCEPTION_VALUE_ID = 'EXCEPTION_VALUE_ID';
    ChromeDebugAdapter.PLACEHOLDER_URL_PROTOCOL = 'debugadapter://';
    ChromeDebugAdapter.SET_BREAKPOINTS_TIMEOUT = 3000;
    return ChromeDebugAdapter;
}(baseDebugAdapter_1.BaseDebugAdapter));
exports.ChromeDebugAdapter = ChromeDebugAdapter;

//# sourceMappingURL=chromeDebugAdapter.js.map
